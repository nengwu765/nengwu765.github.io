<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DevOps启蒙-开发测试管理系统</title>
    <url>/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>这个算是个回顾吧，自己再2019年进入X公司，发现开发测试流程耦合严重，没有独立的测试环境管理平台，所以参照自己的前东家（👉iflow系统）实现了一个<code>简单</code>的开发测试流程管理系统，当时的<code>思想还很稚嫩，观点粗浅</code>（算是自己DevOps启蒙篇吧），仅供参考哈。</p>
<span id="more"></span>
<p><strong>如果你对以下的内容感兴趣，可以一起探讨交流哦……</strong></p>
<ul>
<li>技术开发在项目移交测试后，既可以“放飞自我”、“自由飞翔”</li>
<li>测试妹子如何实现“私人定制”的测试环境，实现简单mock第三方Api</li>
<li>**终极：**如何让开发测试整个流程自动化</li>
</ul>
<h2 id="1%E3%80%81%E2%80%9C%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%E2%80%9D%EF%BC%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">1、“初来乍到”，遇到的问题</h2>
<p>刚来到公司时，项目都是 <strong>小作坊管理方式</strong> 的，项目的流程规范不是很完善，有些项目让我接的有点“措手不及”吧。还有就是在开发移测后，自己需要过度介入整个测试过程，无法正常开始其他方面的工作：</p>
<p>总结以下吧：</p>
<ul>
<li>产品研发流程不完善</li>
<li>测试开发过度耦合，无法有效释放生成力</li>
</ul>
<p>结合我遇到的问题，我会和大家一起探讨解决问题。</p>
<h2 id="2%E3%80%81%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B%E3%80%90%E8%BF%99%E4%B8%8D%E6%98%AF%E6%9C%AC%E6%96%87%E9%87%8D%E7%82%B9%E3%80%91">2、产品研发流程简介【这不是本文重点】</h2>
<p>其实在网上有很多资料，来说明一个互联网产品研发的流程了，基本大同小异。</p>
<p>我主要分以下几个部分简单说一下吧：</p>
<ul>
<li>需求阶段：产品需求调研【为什么要做；做了之后会带来什么好处；最终在数据上怎么体现】，明确需求优先级</li>
<li>方案阶段：产品原型文档，各负责人需求评审，<strong>一线开发&amp;测试</strong> 具体方案评审，排期</li>
<li>开发阶段：设计方案、编码、自测、提测</li>
<li>测试阶段：测试用例、线下测试、stage测试</li>
<li>上线：Beta环境，GA环境</li>
</ul>
<p>其中在产品的需求和方案阶段的流程完善可以通过人为 <strong>强制约束规范</strong> 得到有效解决</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B.gif" alt="img"></p>
<h2 id="3%E3%80%81%E5%BC%80%E5%8F%91%26%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98">3、开发&amp;测试中的问题</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO 大家都是码农，我就懒得说了，😄</span><br></pre></td></tr></table></figure>
<h2 id="4%E3%80%81%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E4%BD%93%E7%B3%BB">4、开发测试流程体系</h2>
<h3 id="4.1%E3%80%81-%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">4.1、 问题如何解决</h3>
<p>问题真实存在，我们应该如何解决呢？怎样才能使我们的工作的更**<code>爽</code>**</p>
<p>我的思考：业务流程化 –&gt; 流程工具化 –&gt; 工具自动化(信息化)</p>
<h3 id="4.2%E3%80%81-%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E4%BD%93%E7%B3%BB">4.2、 开发测试流程体系</h3>
<p>其实很容易，在研发流程当中其实已经说明了开发测试的一个简单的流程体系，其主要就是三个阶段：</p>
<ul>
<li>Dev阶段：开发设计文档、创建分支、编码、自测、测试用例、提测</li>
<li>Test阶段：线下测试、Stage测试、代码审查、产品验收</li>
<li>Online阶段：Beta环境、GA环境</li>
</ul>
<p>流程化的过程如下：</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E6%B5%81%E7%A8%8B%E4%BD%93%E7%B3%BB.gif" alt="img"></p>
<h2 id="5%E3%80%81iflow%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">5、Iflow开发测试流程管理系统</h2>
<p>基于以上的问题和思考，以及以往的经验【这个占绝大部分】，我开发一套开发测试流程管理系统。所有的流程【除特出流程类型，如：<code>hotfix</code>】都是分步骤一步一步往下进行的，可以流程化管理。</p>
<p>Iflow系统特点：</p>
<ul>
<li>记录整个开发测试到上线的整个过程</li>
<li>主子流程明确，不会有流程交叉</li>
<li>严格流程化，当前流程之后的流程<strong>灰色</strong>，不可点击</li>
<li>流程化&amp;权限化，严格把控“出错”风险</li>
<li>测试环境统一化管理，测试可自由定制，mock第三方Api</li>
<li>后续可完善，做成CI系统</li>
</ul>
<h3 id="5.1%E3%80%81iflow-%E2%80%94-%E5%9F%BA%E6%9C%AC%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E">5.1、IFLOW — 基本界面说明</h3>
<ul>
<li>**主流程：**主阶段，创建Iflow、dev阶段、test阶段、online阶段</li>
<li>**子流程：**就是当前主极端对应的子阶段，如下图中 <strong>dev阶段</strong>，对应的开发文档阶段，创建分支……</li>
<li>**开发应用：**目前一个QS，可能需要关联开发多个应用，每个应用可以单独的流程，可以独立区分，便于不同的童鞋开发</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E6%9C%AC%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E.png" alt="img"></p>
<h3 id="5.2%E3%80%81iflow-%E2%80%94-%E5%88%9B%E5%BB%BAiflow%EF%BC%88%E9%80%89%E6%8B%A9%E5%BA%94%E7%94%A8%EF%BC%89">5.2、IFLOW — 创建IFLOW（选择应用）</h3>
<p>目前根据QS-Id建立Iflow流程【注，目前未关联QS系统】，可以选择应用和不同的流程类型创建Iflow流程。</p>
<p>流程类型说明：</p>
<ul>
<li>正常：需要按常规走完流程</li>
<li>bug修复/Notesting/线上紧急bug：可以跳过特定的流程步骤</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="img"></p>
<h3 id="5.3%E3%80%81iflow-%E2%80%94-dev%E9%98%B6%E6%AE%B5">5.3、IFLOW — DEV阶段</h3>
<p>由对应<strong>开发走完整个流程</strong>，上传传文档审核，建立分支，自测，到最后提测。开发走完整个Dev阶段后移交测试。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/dev%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="5.4%E3%80%81iflow-%E2%80%94-test%E9%98%B6%E6%AE%B5">5.4、IFLOW — TEST阶段</h3>
<p>由对应<strong>测试走完整个流程</strong></p>
<blockquote>
<p>首先测试可以在左侧菜单栏【iflow流程列表】，检索对应QS-ID，即可进入对应的流程测试，以及查看dev阶段的api文档和开发文档。</p>
</blockquote>
<blockquote>
<p>其次进入dev阶段完成相应阶段的测试，其中测试环境支持以下的功能：</p>
</blockquote>
<ul>
<li>**释放分支：**释放当前的测试环境绑定</li>
<li>**切换/更新分支：**将当前iflow流程对应的分支，切换至当前的测试环境</li>
<li>**更新dev配置文件：**基于目前环境存在的分支代码，同步copy更新dev配置文件，注意：更新后，原有的定制配置将被覆盖。</li>
<li>**配置文件修改：**更改/定制当前测试环境的配置文件</li>
<li>**模拟APi【mock第三方api数据】：**可以模拟第三方的api返回数据，设置超时，【使用前，注意绑定下对应模拟api的域名IP，不同的环境这个域名和IP不同】。</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/test%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="5.5%E3%80%81iflow-%E2%80%94-online%E9%98%B6%E6%AE%B5">5.5、IFLOW — ONLINE阶段</h3>
<p>即上线至beta环境和GA环境，显示但前版本列表，支持一键回退功能【目前只是一个空架子】。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/online%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h2 id="6%E3%80%81%E6%80%BB%E7%BB%93">6、总结</h2>
<p>整体来说IFLOW开发测试流程管理系统只是一个<strong>流程框架或者外壳</strong>，后续相关的功能的模块都可以进行集成，将其形成一套完善的流程管理系统（整体页面功能可能会比较简陋，当时花费一个多月的闲余时间写的😀）。</p>
<p><strong>可集成功能：</strong></p>
<ul>
<li>**文档系统：**api文档、Wiki知识库</li>
<li>**测试用例系统：**测试编写用例，开发可以审核过测试用例等</li>
<li>**自动化测试系统：**测试自动化测试脚本</li>
<li>**代码管理平台：**可以直接检测代码质量，给代码评分等，比如 <a href="http://bbs.2345.net/d/169-sonarqube/3"><strong>sonarQube，可点击此查看</strong></a></li>
<li>**打包构建工具：**比如jekins（PHP你懂的，木有构建哦😂）</li>
<li><strong>CI可持续集成</strong></li>
<li><strong>发布系统</strong></li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>Iflow</category>
      </categories>
      <tags>
        <tag>Iflow</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(一)-工具选型</title>
    <url>/2021/05/27/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%80)-%E5%B7%A5%E5%85%B7%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>DevOps必不可少的一环就是代码扫描了，这里面包含了编码规范、代码缺陷、性能、漏洞的检测。目前也会有很多的开源静态代码扫描工具，如：SonarQube、Infer、PMD、FindBugs、CheckStyle。针对此做了简单的收集对比，各位可以根据自身的需求进行参考。</p>
<span id="more"></span>
<h2 id="%E5%B7%A5%E5%85%B7%E9%80%89%E5%9E%8B%E8%B0%83%E7%A0%94">工具选型调研</h2>
<h3 id="%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%E8%AF%B4%E6%98%8E">工具对比说明</h3>
<p>目前比较流行的开源的静态代码扫描工具：SonarQube、Infer、PMD、FindBugs、CheckStyle。因为后续会有流程定制化等需求，暂不考虑商业化的软件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">产品</th>
<th style="text-align:center">定位</th>
<th style="text-align:left">OpenApi</th>
<th style="text-align:left">Web项目友好</th>
<th style="text-align:left">支持代码质量检查</th>
<th style="text-align:left">支持语言</th>
<th style="text-align:left">可扩展性/插件支持</th>
<th style="text-align:left">是否侵入项目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SonarQube</td>
<td style="text-align:center">代码质量平台 <br>通过插件的<br>方式提供对各个<br>语言进行支持，<br>可以和 Checkstyle、PMD、Simian <br>等工具进行集成</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">常见语言都支持</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">Infer</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">否（移动端友好）</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">Android/java</td>
<td style="text-align:left">中</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">PMD</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">FindBugs</td>
<td style="text-align:center">字节码分析，侧重Bug检测</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">CheckStyle</td>
<td style="text-align:center">语法层面分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<h3 id="%E9%80%89%E5%9E%8B">选型</h3>
<p>基于上述，<strong>选型SonarQube作为代码扫描工具</strong>，SonarQube 也是是一款目前比较流行的工具，国内很多互联网公司都选择用它来搭建静态检查的平台。</p>
<p>SonarQube介绍: <a href="https://www.sonarqube.org/">官网</a></p>
<h2 id="%E5%AE%9E%E6%96%BD%E8%AE%A1%E5%88%92">实施计划</h2>
<ul>
<li>SonarQube的部署使用调研</li>
<li>代码检测集成方案，（Jenkins、gitlab CI、代码检测时机等）</li>
<li>考虑代码质量平台管理（原生平台界面不友好、同时展示维度无法做到应用维度）</li>
</ul>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><strong>参考资料</strong></h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">资料</th>
<th style="text-align:left">概述</th>
<th style="text-align:left">参考价值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://testerhome.com/articles/24210">酷家乐质量效能 代码度量平台</a></td>
<td style="text-align:left">引入使用 SQALE 代码质量评估模型的 SonarQube 进行代码静态扫描，辅以 Cobra 的进行代码审计，Synk 进行三方包漏洞扫描，形成一套完整的代码度量工具链</td>
<td style="text-align:left"><strong>高</strong><br>整合平台页面参考</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://mp.weixin.qq.com/s/d9RzCFkYrW27m1_LkeA2rw">系列 | 58集团白盒代码审计系统建设实践1：技术选型</a></td>
<td style="text-align:left">对比了常见的的开源方案和商业方案，同时涉及介绍 SDL 相关检测知识</td>
<td style="text-align:left"><strong>高</strong><br>选型对比数据参考</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(三)-Sonar+Jenkins+Gitlab集成</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%89)-Sonar+Jenkins+Gitlab/</url>
    <content><![CDATA[<p>目前我们使用CI工具主要是Jenkins，所以此相互选择了jenkins进行集成。根据实际情况，也可选择GitlabCI等工具。</p>
<p>实施代码检测，Gitlab 代码变更（Push/Merge），触发Jenkins Job执行SonarScanner扫描代码，SonarServer通过Gitlab插件，将代码扫描完的结果回写至Gitlab，GitLab即可查看到对应Sonar检测的结果代码注释，方便开发人员代码排查</p>
<span id="more"></span>
<h2 id="%E5%AE%9E%E7%8E%B0%E7%9B%AE%E7%9A%84">实现目的</h2>
<ul>
<li>1、研发过程，Jenkins在构建过程，加入SonarQube的代码质量门，检测本次构建增量代码质量</li>
<li>2、定期的全量代码质量扫描，在每周定期对公司所有代码进行全量扫描，产出代码质量报告</li>
</ul>
<h2 id="%E9%9B%86%E6%88%90%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE">集成插件配置</h2>
<h3 id="1%E3%80%81jenkins%E6%8F%92%E4%BB%B6%26%E9%85%8D%E7%BD%AE">1、Jenkins插件&amp;配置</h3>
<p><strong>插件：</strong></p>
<ul>
<li>SonarQubeScannerForJenkins</li>
</ul>
<p><strong>配置：</strong></p>
<ul>
<li>SonarServer配置：Manage Jenkins -- &gt; Configure System -- &gt; SonarQube servers<br>
需要SonarQube基于高权限账号生成的 授权token （SonarQube：Administration -- &gt; Security -- &gt; Users）</li>
<li>SonarScanner配置：Manage Jenkins -- &gt; Global Tool Configuration -- &gt; SonarQube Scanner<br>
备注：<strong>这里安装多个SonarQube Scanner，为多项目并行代码扫描做准备</strong></li>
</ul>
<h3 id="2%E3%80%81sonarqube%E9%85%8D%E7%BD%AE">2、SonarQube配置</h3>
<p><strong>插件：</strong></p>
<p>实现gitlab打通，<strong>同时实现gitlab auth授权登陆</strong>。</p>
<ul>
<li>sonar-gitlab-plugin：<a href="https://github.com/javamachr/sonar-gitlab-plugin">https://github.com/javamachr/sonar-gitlab-plugin</a></li>
<li>**sonar-auth-gitlab-plugin：**<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin</a></li>
</ul>
<p>**Sonar Serverbase Url设置：**Administration &gt; Configuration &gt; General&gt; Server base URL</p>
<p><strong>Webhook配置：（实操，不配置，JEnkins在获取质量门结果时会无限等待）</strong></p>
<p>Administration &gt; Configuration &gt; Webhooks. The URL should point to your Jenkins server： <code>http://&#123;JENKINS_HOST&#125;/sonarqube-webhook/</code></p>
<p>具体说明：参考Jenkins官方文档说明（<a href="https://www.jenkins.io/doc/pipeline/steps/sonar/#waitforqualitygate-wait-for-sonarqube-analysis-to-be-completed-and-return-quality-gate-status">Configure a webhook in your SonarQube server pointing</a> ... ）</p>
<p><strong>Gitlab授权登陆：</strong></p>
<p>Administration &gt; Configuration &gt; GitLab &gt; Authentication ：设置对应的 Application ID + Secret</p>
<p>(设置参数说明，参考对应的插件说明：<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">sonar-auth-gitlab-plugin</a>)</p>
<p><strong>Gitlab Reporting配置：</strong></p>
<ul>
<li>
<p>作用：可以将检测结果报告已comment的形式回写至Gitlab的Commit中（注：目前版本不支持inline comment in commit，现在只有global comment，具体看附属问题记录说明）</p>
</li>
<li>
<p>配置：Administration &gt; Configuration &gt; GitLab &gt; Reporting</p>
</li>
<li>
<p>参数：扫描时需要配置参数：sonar.gitlab.project_id</p>
</li>
</ul>
<p>说明：这个可以根据实际需求配置说明，此处可根据需求配置将检测的结果是否以comment回写。此处暂时不配置。</p>
<h3 id="3%E3%80%81gitlab%E9%85%8D%E7%BD%AE">3、Gitlab配置</h3>
<p><strong>授权登陆设置：</strong><br>
Admin Settings -&gt; Application：设置对应的回调：https://<your sonar domain>/oauth2/callback/gitlab (备注：sonar的domain不可为IP+Port形式，经测试http目前也是支持)</your></p>
<h2 id="%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95">问题记录</h2>
<ul>
<li>SonarCloud + GitHub + Pull Request Analysis = No Inline Comments：<a href="https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2">https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2</a><br>
目前最后支持的版本：sonarqube v7.6</li>
<li>新扫描项目（新sonar project key） No branches currently exist in this project. Please scan the main branch without passing any branch parameters<br>
注：新项目必须先扫描 master（稳定）分支，才可以进行其他分支的扫描</li>
<li>不建议写入sonar.language扫描参数： <a href="https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993">https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993</a></li>
<li>SonarQube插件矩阵（可查看相关产检兼容情况）：<a href="https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/">https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/</a></li>
</ul>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(二)-SonarQube安装</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%BA%8C)-SonarQube%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>SonarQube的安装会给予版本有些差异，建议根据你选择的版本结合官方的文档进行安装，中间遇到问题再自行Google一下啦。本文主要是讲解一下版本的安装：SonarQube：7.9 LTS +PostgreSQL 10</p>
<span id="more"></span>
<h2 id="%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9">版本选择</h2>
<p>不同的版本对应的插件选择和数据库支持不同，同时需要考虑版本的稳定性。考虑稳定性，避免出现问题无法跟进处理解决，生产环境不考虑最新版本。</p>
<p>SonarQube：7.9 LTS</p>
<p>SonarQube v7.9 的前置依赖说明（<a href="https://docs.sonarqube.org/7.9/requirements/requirements/%EF%BC%89">https://docs.sonarqube.org/7.9/requirements/requirements/）</a></p>
<ul>
<li>数据库：PostgreSQL 10</li>
<li>Java JDK：OpenJDK 11</li>
</ul>
<h2 id="%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E">安装说明</h2>
<h3 id="1%E3%80%81openjdk-11%E5%AE%89%E8%A3%85">1、OpenJDK 11安装</h3>
<p>官方安装引导：<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a></p>
<p>安装包（Linux/x64）：（<a href="https://download.java.net/openjdk/jdk11/ri/openjdk-11+28_linux-x64_bin.tar.gz">官方下载</a> ）</p>
<p><strong>解压缩</strong></p>
<p>&gt; tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz</p>
<p><strong>配置环境变量</strong></p>
<p>&gt; 末尾增加如下内容(根据自己jdk目录修改)：<br>
&gt; export JAVA_HOME=/usr/local/jdk-11<br>
&gt; export CLASSPATH=$JAVA_HOME/lib:$CLASSPATH<br>
&gt; export PATH=$JAVA_HOME/bin:$PATH</p>
<p><strong>验证</strong></p>
<p>&gt; java -version</p>
<h3 id="2%E3%80%81postgresql-10%E5%AE%89%E8%A3%85">2、PostgreSQL 10安装</h3>
<p>官方的安装引导：<a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></p>
<ul>
<li>Select version：10</li>
<li>Select platform：CentOS 7</li>
<li>Select architecture: x86_64</li>
</ul>
<p>执行安装脚本及初始化启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装repo源</span></span><br><span class="line">sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装服务端</span></span><br><span class="line">sudo yum install -y postgresql10-server</span><br><span class="line"> </span><br><span class="line"><span class="comment"># PGsql进行初始化</span></span><br><span class="line">sudo /usr/pgsql-10/bin/postgresql-10-setup initdb</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加入开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启动PGsql</span></span><br><span class="line">stl start postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status postgresql-10.service</span><br></pre></td></tr></table></figure>
<p>初始化SonarQube使用的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接到数据库</span></span><br><span class="line">psql</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">CREATE DATABASE sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER sonarqube WITH PASSWORD <span class="string">&#x27;xxxxx&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE sonarqube TO sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建授权（必须）</span></span><br><span class="line">ALTER DATABASE sonarqube owner to sonarqube;</span><br></pre></td></tr></table></figure>
<p>修改pg数据的pg_hba.conf（<a href="http://www.postgres.cn/docs/10/auth-pg-hba-conf.html"><code>pg_hba.conf</code>文件说明</a>）将认证 ident 改为 md5，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># &quot;local&quot; is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all             all                                     peer</span><br><span class="line"><span class="comment"># IPv4 local connections:</span></span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line"><span class="comment"># IPv6 local connections:</span></span><br><span class="line">host    all             all             ::1/128                 md5</span><br><span class="line"><span class="comment"># Allow replication connections from localhost, by a user with the</span></span><br><span class="line"><span class="comment"># replication privilege.</span></span><br><span class="line"><span class="comment">#local   replication     postgres                                peer</span></span><br><span class="line"><span class="comment">#host    replication     postgres        127.0.0.1/32            ident</span></span><br><span class="line"><span class="comment">#host    replication     postgres        ::1/128                 ident</span></span><br><span class="line"><span class="comment">#host    replication     sonar           127.0.0.1/32            ident</span></span><br></pre></td></tr></table></figure>
<h3 id="3%E3%80%81sonarqube-7.9%E5%AE%89%E8%A3%85">3、SonarQube 7.9安装</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/setup/install-server/">https://docs.sonarqube.org/7.9/setup/install-server/</a></p>
<p>安装包：（<a href="https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.9.6.zip">官方下载</a>）</p>
<p><strong>创建sonar用户</strong></p>
<p>&gt; sudo useradd sonar</p>
<p>&gt; passwd sonar (密码：xxxx)</p>
<p>linux平台文件数限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置系统最大文件数</span></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">sysctl -w fs.file-max=65536</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置sonar用户再打文件数 文件：/etc/security/limits.d/99-sonarqube.conf (or /etc/security/limits.conf as you wish)，注：终端需退出重登生效或source后生效？</span></span><br><span class="line">sonar -   nofile   65536</span><br><span class="line">sonar -   nproc    4096</span><br></pre></td></tr></table></figure>
<p><strong>安装配置</strong></p>
<ul>
<li>数据库链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.jdbc.username=sonarqube</span><br><span class="line">&gt; sonar.jdbc.password=mypassword</span><br><span class="line">&gt; sonar.jdbc.url=jdbc:postgresql://localhost/sonarqube</span><br></pre></td></tr></table></figure>
<ul>
<li>ES存储</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.path.data=/opt/data/sonarqube/data</span><br><span class="line">&gt; sonar.path.temp=/opt/data/sonarqube/temp</span><br></pre></td></tr></table></figure>
<ul>
<li>Web Server配置</li>
</ul>
<p>自己设定启动端口配置即可</p>
<p><strong>脚本启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="variable">$&#123;sonar_home&#125;</span>/bin/linux-x86-64/sonar.sh start</span><br></pre></td></tr></table></figure>
<p>服务器部署，注意加入到开机启动项中,，此处我是加入 rc.local 文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sonarqube server</span></span><br><span class="line">su - sonar -c <span class="string">&quot;/opt/app/sonarqube/sonarqube-7.9.6/bin/linux-x86-64/sonar.sh start&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="4%E3%80%81sonarqube-scanner">4、SonarQube Scanner</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/</a></p>
<p>安装包：（<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">官方下载</a>）</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置SonarQube Server，位置：$install_directory/conf/sonar-scanner.properties</span></span><br><span class="line"><span class="comment">#----- Default SonarQube server</span></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将$install_directory/bin，加入到环境变量PATH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 sonar-scanner -h ，做验证</span></span><br></pre></td></tr></table></figure>
<p>**每个扫描项目的根目录加入：**sonar-project.properties</p>
<p>sonar-project.properties示例： <a href="https://github.com/SonarSource/sonar-scanning-examples">browsed</a> or <a href="https://github.com/SonarSource/sonar-scanning-examples/archive/master.zip">downloaded</a></p>
<h3 id="5%E3%80%81sonarqube-plugin">5、SonarQube Plugin</h3>
<ul>
<li>社区版支持多分支检测： <a href="https://github.com/mc1arke/sonarqube-community-branch-plugin">sonarqube-community-branch-plugin</a>（1.3.2老版本，安装<a href="https://github.com/mc1arke/sonarqube-community-branch-plugin/commit/a6b6db3f30e1ebba7183825542d1f5363b66a831#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5">区别现说明</a>：Copy the plugin JAR file to the <code>extensions/plugins/</code> <strong>and</strong> the <code>lib/common/</code> directories of your SonarQube instance and restart SonarQube）</li>
<li>汉化包（不建议，总觉得怪怪的）：直接在应用市场检索按照对应的版本即可（jar插件下载：<a href="https://github.com/xuhuisheng/sonar-l10n-zh">sonar-l10n-zh</a>）</li>
</ul>
<h3 id="6%E3%80%81%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">6、相关配置</h3>
<ul>
<li><strong>解决增量代码小于20行，QG不生效情况：</strong></li>
</ul>
<p>&gt; 配置：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<h2 id="%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95">问题记录</h2>
<p><strong>1、Some Quality Gate conditions on New Code were ignored because of the small number of New Lines</strong></p>
<p>但分支模式增量代码扫描，少于20行时，代码坏味道无法检测到，可以参考：<a href="https://jira.sonarsource.com/browse/SONAR-9352">SONAR-9352</a> 或 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a></p>
<p>解决：解决方案说明参考 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a>，</p>
<p>步骤：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<p><strong>2、the main branch has no lines of code</strong></p>
<p>扫描php，遇到的错误，主要原因是唯一的php的文件在解析阶段就出现错误，无法正常解析，也就没有扫描文件，更没有扫描结果了。</p>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<ol>
<li><a href="https://bbs.huaweicloud.com/blogs/159762">SonarQube安装及踩坑体验</a></li>
<li><a href="https://blog.csdn.net/CN_TangZheng/article/details/109244806">调研sonarqube版本区别</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1732805">从零开始针对 .NET 应用的 DevOps 运营实践 - Jenkins &amp; SonarQube 安装配置</a></li>
</ol>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Pipeline语法详解</title>
    <url>/2021/05/27/Jenkins/Jenkins%20Pipeline%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>如何编写流水线文件jenkinsfile呢？其实其重点是使用<code>Pipeline语法</code>。 所以此处将重点介绍如何使用Pipeline的语法，从Pipeline插件2.5版开始，Pipeline支持两种独立的语法结构：<strong>Declarative Pipeline</strong> 和 <strong>Scripted Pipeline</strong>，两者都支持建立连续传送的Pipeline。</p>
<span id="more"></span>
<h2 id="1-%E6%A6%82%E8%BF%B0">1 概述</h2>
<p>先说下最后的选择吧，为与BlueOcean编辑器兼容，<code>建议使用Declarative Pipeline的方式进行编写</code>,这种语法结构也会是Jenkins Pipeline未来发展的趋势。</p>
<h2 id="2-declarative-pipeline">2 Declarative Pipeline</h2>
<p>从Pipeline2.5版本以后，Jenkins Pipeline新增了一种新的语法类型Declarative Pipeline（声明式Pipeline），它在Pipeline系统之上提供了一种更加简单和有意义的语法。</p>
<p>所有有效的Declarative Pipeline必须包含在一个pipeline块内，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123; </span><br><span class="line"><span class="comment">/* insert Declarative Pipeline here */</span> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Declarative Pipeline遵循与Groovy相同的语法规则，但有以下几点例外：</p>
<ul>
<li>
<p>Pipeline的顶层必须是块，具体来说就是：pipeline { }。</p>
</li>
<li>
<p>不用分号作为语句分隔符，每个声明必须独立一行。</p>
</li>
<li>
<p>块里只能包含Sections（章节）、Directives（指令）、 Steps（步骤）或赋值语句。</p>
</li>
<li>
<p>属性引用以无参方法的方式调用。例如，输入被视为input（）。</p>
</li>
</ul>
<h3 id="2.1-sections%EF%BC%88%E7%AB%A0%E8%8A%82%EF%BC%89">2.1 Sections（章节）</h3>
<p>Declarative Pipeline里的Sections通常包含一个或多个Directives或Steps。</p>
<h4 id="agent">agent</h4>
<p>agent指定整个Pipeline或特定stage在Jenkins环境中执行的位置。在pipeline代码块的顶层agent必须进行定义，但在stage级使用是可选的。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">见参数说明</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8">参数列表</h5>
<p>为实现Pipeline可能拥有的各种用例，agent支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p>
<p><strong>any</strong></p>
<p>在任何可用的agent 上执行Pipeline或stage。例如：agent any<br>
<strong>none</strong></p>
<p>当在pipeline块的顶层使用none时，将不会为整个Pipeline运行分配全局agent ，每个stage部分将需要定义其自己的agent。</p>
<p><strong>label</strong></p>
<p>提供label标签名称，在Jenkins环境中可用的agent上执行Pipeline或stage。</p>
<p label my-defined-label>例如：agent</p>
<p><strong>node</strong></p>
<p>agent { node { label 'labelName' } }，等同于 agent { label 'labelName' }，但node也允许其他选项（如customWorkspace）。</p>
<p><strong>docker</strong></p>
<p>定义此参数时，执行Pipeline或stage时会动态提供一个docker节点去运行基于Docker的Pipelines。docker还可以接受一个args参数，直接传递给docker run指令调用。</p>
<p>例如：agent { docker 'maven:3-alpine' }或</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        image <span class="string">&#x27;maven:3-alpine&#x27;</span></span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        args  <span class="string">&#x27;-v /tmp:/tmp&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>dockerfile</strong></p>
<p>使用从Dockerfile仓库中包含的dockerfile创建镜像文件来构建执行Pipeline或stage。为了使用此选项，Jenkinsfile必须从Multibranch Pipeline或“Pipeline from SCM&quot;中加载。</p>
<p>默认目录是在Dockerfile仓库的根目录：agent { dockerfile true }。如果Dockerfile需在另一个目录中建立，可使用dir选项：agent { dockerfile { dir 'someSubDir' } }。</p>
<p>还可以通过docker build ...使用additionalBuildArgs选项，如agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }。</p>
<h5 id="%E9%80%9A%E7%94%A8%E9%80%89%E9%A1%B9">通用选项</h5>
<p>这些是可以应用于两个或多个agent中的选项。除非明确定义，否则非必需。</p>
<p><strong>label</strong></p>
<p>string字符串。标记在哪里运行pipeline或stage</p>
<p>此选项适用于node，docker和dockerfile，并且在node中是必需的。<br>
<strong>customWorkspace</strong></p>
<p>string字符串。自定义运行的工作空间,它可以是相对路径，在这种情况下，自定义工作区将位于node节点工作空间的根目录下，也可以是绝对路径。例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    node &#123;</span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        customWorkspace <span class="string">&#x27;/some/other/path&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reuseNode</strong><br>
一个布尔值，默认为false。如果为true，则在同一工作空间中，此选项适用于docker和dockerfile，并且仅在独立stage中使用agent时才有效。</p>
<h5 id="%E6%A0%B7%E4%BE%8B">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn -B clean verify&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>使用‘maven:3-alpine’的镜像创建容器，执行pipeline的所有步骤。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent none ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ②</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, Maven&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Test&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;openjdk:8-jre&#x27;</span> &#125; ③</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, JDK&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;java -version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>agent none在Pipeline顶层定义，表示将不会为整个Pipeline运行分配全局agent，每个stage需自己设置agent。</p>
<p><strong>②</strong>使用‘maven:3-alpine’的镜像创建容器，执行此阶段中的步骤。</p>
<p><strong>③</strong>使用‘openjdk:8-jre’的镜像创建容器，执行此阶段中的步骤。</p>
<h4 id="post">post</h4>
<p>定义Pipeline或stage运行结束后的操作。post支持以下类型的代码块：always，changed，failure，success，unstable和aborted。这些代码块允许在Pipeline或stage运行结束时执行相关步骤，具体取决于Pipeline的运行状态。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8-1">参数列表</h5>
<p><strong>always</strong></p>
<p>结束时运行，无论Pipeline运行的完成状态如何。</p>
<p><strong>changed</strong></p>
<p>只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能运行。</p>
<p><strong>failure</strong></p>
<p>只有当前Pipeline处于“失败”状态时才运行，通常用红色指示的Web UI表示。</p>
<p><strong>success</strong></p>
<p>只有当前Pipeline具有“成功”状态时才运行，通常用蓝色或绿色指示的Web UI表示。</p>
<p><strong>unstable</strong></p>
<p>只有当前Pipeline具有“不稳定”状态，一般由测试失败，代码违例等引起，才能运行。通常用黄色指示的Web UI表示。</p>
<p><strong>aborted</strong></p>
<p>只有当前Pipeline处于“中止”状态时，才会运行，通常是由于Pipeline被手动中止。通常用灰色指示的Web UI表示。</p>
<h5 id="%E6%A0%B7%E4%BE%8B-1">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">&#x27;I will always say Hello again!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①post章节通常会放在pipeline末端。</p>
<p>②post代码块里包括steps章节的内容。</p>
<h4 id="stages">stages</h4>
<p>包含一个或多个stage的序列，Pipeline的大部分工作在此执行。建议stages至少包含至少一个stage指令，用于连接各个交付过程，如构建，测试和部署等。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="%E6%A0%B7%E4%BE%8B-2">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>stages章节通常跟随在agent,options等指令后面。</p>
<h4 id="steps">steps</h4>
<p>steps包含一个或多个在stage块中执行的step序列。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在每个stage代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="%E6%A0%B7%E4%BE%8B-3">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; </span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;①</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>① steps章节必须包括一个或多个step。</strong></p>
<h3 id="2.2-directives-%EF%BC%88%E6%8C%87%E4%BB%A4%EF%BC%89">2.2 Directives （指令）</h3>
<h4 id="environment">environment</h4>
<p>environment指令指定一系列键值对，这些键值对将被定义为所有step或stage中step的环境变量，具体取决于environment指令在Pipeline中的位置。</p>
<p>该指令支持一种特殊的方法credentials()，可通过标识符访问Jenkins环境中预定义好的Credential凭证。</p>
<p>对于“Secret Text”类型的凭据，credentials()方法需确保指定的环境变量包含Secret Text内容，对于“Standard username and password&quot;”类型的凭证，指定的环境变量需要设置为username:password。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="%E6%A0%B7%E4%BE%8B-4">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">environment</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">&#x27;clang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">&#x27;my-prefined-secret-text&#x27;</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;printenv&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>environment指令放在pipeline顶级块中，将适用pipeline所有步骤。</p>
<p><strong>②</strong>environment指令放在stage中，给定的环境变量将只适用该stage中的步骤。</p>
<p><strong>③</strong>environment块中使用credentials()方法，可以访问Jenkins环境中预定义的凭证。</p>
<h4 id="options">options</h4>
<p>options指令允许在Pipeline内配置Pipeline专用选项。Pipeline本身提供了许多选项，例如buildDiscarder，它们也可以由Jenkins插件提供，例如 timestamps。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8-2">参数列表</h5>
<p><strong>buildDiscarder</strong></p>
<p>pipeline保持构建的最大个数。例如：</p>
<p builddiscarder(logrotator(numtokeepstr: 1))>options</p>
<p><strong>disableConcurrentBuilds</strong></p>
<p>不允许并行执行Pipeline,可用于防止同时访问共享资源等。例如：</p>
<p disableconcurrentbuilds()>options</p>
<p><strong>skipDefaultCheckout</strong></p>
<p>默认跳过来自源代码控制的代码。例如：</p>
<p skipdefaultcheckout()>options</p>
<p><strong>skipStagesAfterUnstable</strong></p>
<p>一旦构建状态进入了“Unstable”状态，就跳过此stage。例如：</p>
<p skipstagesafterunstable()>options</p>
<p><strong>timeout</strong><br>
设置Pipeline运行的超时时间。例如：</p>
<p>options {timeout(time: 1, unit: 'HOURS')}F</p>
<p><strong>retry</strong></p>
<p>失败后，重试整个Pipeline的次数。例如：</p>
<p retry(3)>options</p>
<p><strong>timestamps</strong></p>
<p>预定义由Pipeline生成的所有控制台输出时间。例如：</p>
<p timestamps()>options</p>
<h5 id="%E6%A0%B7%E4%BE%8B-5">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123; </span><br><span class="line">        timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>) ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>设置pipeline全局的超时时间为1小时，超时后将会自动终止pipeline运行。</p>
<h4 id="parameters">parameters</h4>
<p>parameters指令提供用户在触发Pipeline时的参数列表。这些参数值通过params对象可用于Pipeline步骤，具体用法如下</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8-3">参数列表</h5>
<p><strong>string</strong></p>
<p>string类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123; </span><br><span class="line">string(<span class="attr">name:</span> <span class="string">&#x27;DEPLOY_ENV&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;staging&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>booleanParam</strong></p>
<p>boolean类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123;</span><br><span class="line"> booleanParam(<span class="attr">name:</span> <span class="string">&#x27;DEBUG_BUILD&#x27;</span>, <span class="attr">defaultValue:</span> <span class="literal">true</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截至发稿，Jenkins社区目前已支持[booleanParam, choice, credentials, file, text, password, run, string]这几种参数类型，其他高级参数化类型也在陆续完善中。</p>
<h5 id="%E6%A0%B7%E4%BE%8B-6">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="attr">name:</span> <span class="string">&#x27;PERSON&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;Mr Jenkins&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Who should I say hello to?&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Hello $&#123;params.PERSON&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggers">triggers</h4>
<p>triggers指令定义了Pipeline自动化触发的方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成也已经存在。目前只有两个可用的触发器：cron、pollSCM和upstream。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<p><strong>cron</strong></p>
<p>接受一个cron风格的字符串来定义Pipeline触发的常规间隔，例如：</p>
<p 0 cron(h 4* 1-5)>triggers</p>
<p 0 pollscm(h 4* 1-5)><strong>pollSCM</strong><br>
接受一个cron风格的字符串来定义Jenkins检查SCM源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers</p>
<p><strong>upstream</strong></p>
<p upstream(upstreamprojects: job1,job2, threshold: hudson.model.result.success)>可接受多个job名称以及一个threshold设置参数。任何一个job以符合threshold条件完成后，均可以触发Pipeline的运行。举例：</p>
<h5 id="%E6%A0%B7%E4%BE%8B-7">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">&#x27;H 4/* 0 0 1-5&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stage">stage</h4>
<p>stage指令包含在stages中，包含step、agent（可选）或其他特定包含于stage中的指令。实际上，Pipeline完成的所有实际工作都包含在一个或多个stage指令中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">至少一个</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">一个强制参数，一个标识stage名称的字符串。</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stages章节内。</td>
</tr>
</tbody>
</table>
<h5 id="%E6%A0%B7%E4%BE%8B-8">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tools">tools</h4>
<p>通过tools可自动安装工具，并放置环境变量到PATH。如果agent none，这将被忽略。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<p><strong>支持的Tools</strong></p>
<p>maven</p>
<p>jdk</p>
<p>gradle</p>
<h5 id="%E6%A0%B7%E4%BE%8B-9">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">&#x27;apache-maven-3.0.1&#x27;</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>调用的tool必须被预置在Jenkins中，可通过<strong>Manage Jenkins</strong>→<strong>Global Tool Configuration配置。</strong></p>
<h4 id="when">when</h4>
<p>when指令允许Pipeline根据给定的条件确定是否执行该阶段。when指令必须至少包含一个条件，如果when指令包含多个条件，则只有所有子条件返回true时才会执行stage，这与子条件嵌套在allOf相同（见下面的例子）。</p>
<p>更复杂的条件结构可使用嵌套条件：not，allOf或anyOf，嵌套条件可以嵌套到任意深度。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="%E5%86%85%E7%BD%AE%E6%9D%A1%E4%BB%B6">内置条件</h5>
<p><strong>branch</strong></p>
<p>当正在构建的分支与给出的分支模式匹配时执行，例如：when { branch 'master' }。请注意，这仅适用于multibranch Pipeline。</p>
<p><strong>environment</strong></p>
<p environment name: deploy_to, value: production>当指定的环境变量设置为指定值时执行，例如： when</p>
<p><strong>expression</strong></p>
<p>当指定的Groovy表达式求值为true时执行，例如： when { expression { return params.DEBUG_BUILD } }</p>
<p><strong>not</strong></p>
<p>当嵌套条件为false时执行。必须包含一个条件。例如：when { not { branch 'master' } }</p>
<p><strong>allOf</strong></p>
<p>当所有嵌套条件都为true时执行。必须至少包含一个条件。例如：when { allOf { branch 'master'; environment name: 'DEPLOY_TO', value: 'production' } }</p>
<p><strong>anyOf</strong></p>
<p>当至少一个嵌套条件为真时执行。必须至少包含一个条件。例如：when { anyOf { branch 'master'; branch 'staging' } }</p>
<h5 id="%E6%A0%B7%E4%BE%8B-10">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;production&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; BRANCH_NAME ==~ <span class="regexp">/(production|staging)/</span> &#125;</span><br><span class="line">                anyOf &#123;</span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;production&#x27;</span></span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;staging&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2.3-parallel(%E5%B9%B6%E8%A1%8C)">2.3 Parallel(并行)</h3>
<p>Declarative Pipeline的stages中可能包含多个嵌套的stage, 对相互不存在依赖的stage可以通过并行的方式执行，以提升pipeline的运行效率。</p>
<p>另外，通过在某个stage中设置“failFast true”，可实现当这个stage运行失败的时候，强迫所有parallel stages中止运行（详见下面的例子）。</p>
<h5 id="%E6%A0%B7%E4%BE%8B-11">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Non-Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;This stage will be executed first.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            failFast <span class="literal">true</span></span><br><span class="line">            parallel &#123;</span><br><span class="line">                stage(<span class="string">&#x27;Branch A&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-a&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch A&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stage(<span class="string">&#x27;Branch B&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-b&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch B&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2.4-steps%EF%BC%88%E6%AD%A5%E9%AA%A4%EF%BC%89">2.4 Steps（步骤）</h3>
<p>Declarative Pipeline可使用Pipeline Steps手册中的所有可用步骤，以及以下仅在Declarative Pipeline中支持的步骤。</p>
<p>Pipeline Stepsreference：<a href="https://jenkins.io/doc/pipeline/steps/">https://jenkins.io/doc/pipeline/steps/</a></p>
<h4 id="script">script</h4>
<p>script步骤中可以引用script Pipeline语句，并在Declarative Pipeline中执行。对于大多数用例，script在Declarative Pipeline中的步骤不是必须的，但它可以提供一个有用的加强。</p>
<h5 id="%E6%A0%B7%E4%BE%8B-12">样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">&#x27;chrome&#x27;</span>, <span class="string">&#x27;firefox&#x27;</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">&quot;Testing the $&#123;browsers[i]&#125; browser&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-scripted-pipeline">3 Scripted Pipeline</h2>
<p>Groovy脚本不一定适合所有使用者，因此Jenkins创建了Declarative Pipeline，为编写Jenkins Pipeline提供了一种更简单、更有意义的语法。但是不可否认，由于脚本化的pipeline是基于groovy的一种DSL语言，所以与Declarative pipeline相比为Jenkins用户提供了更巨大的灵活性和可扩展性。</p>
<h3 id="3.1-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">3.1 流程控制</h3>
<p>Pipeline脚本同其它脚本语言一样，从上至下顺序执行，它的流程控制取决于Groovy表达式，如if/else条件语句，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (env.BRANCH_NAME == <span class="string">&#x27;master&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&#x27;I only execute on the master branch&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            echo <span class="string">&#x27;I execute elsewhere&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline脚本流程控制的另一种方式是Groovy的异常处理机制。当任何一个步骤因各种原因而出现异常时，都必须在Groovy中使用try/catch/finally语句块进行处理，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sh <span class="string">&#x27;exit 1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exc) &#123;</span><br><span class="line">            echo <span class="string">&#x27;Something failed, I should sound the klaxons!&#x27;</span></span><br><span class="line">            <span class="keyword">throw</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3.2-steps">3.2 Steps</h3>
<p>如本章开始所言，pipeline最核心和基本的部分就是“step”。从根本上来说，steps是作为Declarative pipeline和Scripted pipeline语法的最基本的语句块，来告诉jenkins应该执行什么操作。</p>
<p>Scripted pipeline不再专门将steps作为它的语法的一部分来介绍，但是在Pipeline Steps reference这篇文档中对pipeline及其插件涉及的steps做了很详细的介绍。如有需要可参考Jenkins官网对该部分的介绍。</p>
<h3 id="3.3-%E4%B8%8E%E6%99%AE%E9%80%9Agroovy%E7%9A%84%E5%8C%BA%E5%88%AB">3.3 与普通Groovy的区别</h3>
<p>由于pipeline的一些个性化需求，比如在重新启动Jenkins后要求pipeline脚本仍然可以运行，那么pipeline脚本必须将相关数据做序列化，然而这一点 Groovy并不能完美的支持。</p>
<h3 id="3.4-declarative-pipeline%E5%92%8Cscripted-pipeline%E7%9A%84%E6%AF%94%E8%BE%83">3.4 Declarative Pipeline和Scripted Pipeline的比较</h3>
<p>共同点：</p>
<p>两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。</p>
<p>区别：</p>
<p>两者不同之处在于语法和灵活性。Declarative Pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。</p>
<h2 id="4-%E5%B0%8F%E7%BB%93">4 小结</h2>
<p>Pipeline语法是使用Jenkins Pipeline的基础，Jenkins提供了Declarative Pipeline和Scripted Pipeline两种语法结构，这两者在底层都是基于相同的Pipeline子系统，依照&quot;Pipeline as code&quot;的理念进行实现。</p>
<p>相对来说，Declarative Pipeline语法更简洁也更容易理解，而且可以与BlueOcean编辑器进行图形化操作结合，也是Jenkins社区鼓励使用的一种语法结构。</p>
<p>基于以上原因，<code>后面我们的交付流水线样例均采用 **Declarative语法** 结构进行编写。</code></p>
<h2 id="5-%E5%BC%95%E7%94%A8">5 引用</h2>
<p><a href="https://jenkins.io/doc/book/pipeline/syntax/">Jenkins Pipeline 语法官方文档参考</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
</search>
