<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DevOps启蒙-开发测试管理系统</title>
    <url>/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>这个算是个回顾吧，自己再2019年进入X公司，发现开发测试流程耦合严重，没有独立的测试环境管理平台，所以参照自己的前东家（👉iflow系统）实现了一个<code>简单</code>的开发测试流程管理系统，当时的<code>思想还很稚嫩，观点粗浅</code>（算是自己DevOps启蒙篇吧），仅供参考哈。</p>
<span id="more"></span>
<p><strong>如果你对以下的内容感兴趣，可以一起探讨交流哦……</strong></p>
<ul>
<li>技术开发在项目移交测试后，既可以“放飞自我”、“自由飞翔”</li>
<li>测试妹子如何实现“私人定制”的测试环境，实现简单mock第三方Api</li>
<li>**终极：**如何让开发测试整个流程自动化</li>
</ul>
<h2 id="1-初来乍到遇到的问题"><a class="markdownIt-Anchor" href="#1-初来乍到遇到的问题"></a> 1、“初来乍到”，遇到的问题</h2>
<p>刚来到公司时，项目都是 <strong>小作坊管理方式</strong> 的，项目的流程规范不是很完善，有些项目让我接的有点“措手不及”吧。还有就是在开发移测后，自己需要过度介入整个测试过程，无法正常开始其他方面的工作：</p>
<p>总结以下吧：</p>
<ul>
<li>产品研发流程不完善</li>
<li>测试开发过度耦合，无法有效释放生成力</li>
</ul>
<p>结合我遇到的问题，我会和大家一起探讨解决问题。</p>
<h2 id="2-产品研发流程简介这不是本文重点"><a class="markdownIt-Anchor" href="#2-产品研发流程简介这不是本文重点"></a> 2、产品研发流程简介【这不是本文重点】</h2>
<p>其实在网上有很多资料，来说明一个互联网产品研发的流程了，基本大同小异。</p>
<p>我主要分以下几个部分简单说一下吧：</p>
<ul>
<li>需求阶段：产品需求调研【为什么要做；做了之后会带来什么好处；最终在数据上怎么体现】，明确需求优先级</li>
<li>方案阶段：产品原型文档，各负责人需求评审，<strong>一线开发&amp;测试</strong> 具体方案评审，排期</li>
<li>开发阶段：设计方案、编码、自测、提测</li>
<li>测试阶段：测试用例、线下测试、stage测试</li>
<li>上线：Beta环境，GA环境</li>
</ul>
<p>其中在产品的需求和方案阶段的流程完善可以通过人为 <strong>强制约束规范</strong> 得到有效解决</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B.gif" alt="img"></p>
<h2 id="3-开发测试中的问题"><a class="markdownIt-Anchor" href="#3-开发测试中的问题"></a> 3、开发&amp;测试中的问题</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO 大家都是码农，我就懒得说了，😄</span><br></pre></td></tr></table></figure>
<h2 id="4-开发测试流程体系"><a class="markdownIt-Anchor" href="#4-开发测试流程体系"></a> 4、开发测试流程体系</h2>
<h3 id="41-问题如何解决"><a class="markdownIt-Anchor" href="#41-问题如何解决"></a> 4.1、 问题如何解决</h3>
<p>问题真实存在，我们应该如何解决呢？怎样才能使我们的工作的更**<code>爽</code>**</p>
<p>我的思考：业务流程化 –&gt; 流程工具化 –&gt; 工具自动化(信息化)</p>
<h3 id="42-开发测试流程体系"><a class="markdownIt-Anchor" href="#42-开发测试流程体系"></a> 4.2、 开发测试流程体系</h3>
<p>其实很容易，在研发流程当中其实已经说明了开发测试的一个简单的流程体系，其主要就是三个阶段：</p>
<ul>
<li>Dev阶段：开发设计文档、创建分支、编码、自测、测试用例、提测</li>
<li>Test阶段：线下测试、Stage测试、代码审查、产品验收</li>
<li>Online阶段：Beta环境、GA环境</li>
</ul>
<p>流程化的过程如下：</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E6%B5%81%E7%A8%8B%E4%BD%93%E7%B3%BB.gif" alt="img"></p>
<h2 id="5-iflow开发测试流程管理系统"><a class="markdownIt-Anchor" href="#5-iflow开发测试流程管理系统"></a> 5、Iflow开发测试流程管理系统</h2>
<p>基于以上的问题和思考，以及以往的经验【这个占绝大部分】，我开发一套开发测试流程管理系统。所有的流程【除特出流程类型，如：<code>hotfix</code>】都是分步骤一步一步往下进行的，可以流程化管理。</p>
<p>Iflow系统特点：</p>
<ul>
<li>记录整个开发测试到上线的整个过程</li>
<li>主子流程明确，不会有流程交叉</li>
<li>严格流程化，当前流程之后的流程<strong>灰色</strong>，不可点击</li>
<li>流程化&amp;权限化，严格把控“出错”风险</li>
<li>测试环境统一化管理，测试可自由定制，mock第三方Api</li>
<li>后续可完善，做成CI系统</li>
</ul>
<h3 id="51-iflow-基本界面说明"><a class="markdownIt-Anchor" href="#51-iflow-基本界面说明"></a> 5.1、IFLOW — 基本界面说明</h3>
<ul>
<li>**主流程：**主阶段，创建Iflow、dev阶段、test阶段、online阶段</li>
<li>**子流程：**就是当前主极端对应的子阶段，如下图中 <strong>dev阶段</strong>，对应的开发文档阶段，创建分支……</li>
<li>**开发应用：**目前一个QS，可能需要关联开发多个应用，每个应用可以单独的流程，可以独立区分，便于不同的童鞋开发</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E6%9C%AC%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E.png" alt="img"></p>
<h3 id="52-iflow-创建iflow选择应用"><a class="markdownIt-Anchor" href="#52-iflow-创建iflow选择应用"></a> 5.2、IFLOW — 创建IFLOW（选择应用）</h3>
<p>目前根据QS-Id建立Iflow流程【注，目前未关联QS系统】，可以选择应用和不同的流程类型创建Iflow流程。</p>
<p>流程类型说明：</p>
<ul>
<li>正常：需要按常规走完流程</li>
<li>bug修复/Notesting/线上紧急bug：可以跳过特定的流程步骤</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="img"></p>
<h3 id="53-iflow-dev阶段"><a class="markdownIt-Anchor" href="#53-iflow-dev阶段"></a> 5.3、IFLOW — DEV阶段</h3>
<p>由对应<strong>开发走完整个流程</strong>，上传传文档审核，建立分支，自测，到最后提测。开发走完整个Dev阶段后移交测试。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/dev%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="54-iflow-test阶段"><a class="markdownIt-Anchor" href="#54-iflow-test阶段"></a> 5.4、IFLOW — TEST阶段</h3>
<p>由对应<strong>测试走完整个流程</strong></p>
<blockquote>
<p>首先测试可以在左侧菜单栏【iflow流程列表】，检索对应QS-ID，即可进入对应的流程测试，以及查看dev阶段的api文档和开发文档。</p>
</blockquote>
<blockquote>
<p>其次进入dev阶段完成相应阶段的测试，其中测试环境支持以下的功能：</p>
</blockquote>
<ul>
<li>**释放分支：**释放当前的测试环境绑定</li>
<li>**切换/更新分支：**将当前iflow流程对应的分支，切换至当前的测试环境</li>
<li>**更新dev配置文件：**基于目前环境存在的分支代码，同步copy更新dev配置文件，注意：更新后，原有的定制配置将被覆盖。</li>
<li>**配置文件修改：**更改/定制当前测试环境的配置文件</li>
<li>**模拟APi【mock第三方api数据】：**可以模拟第三方的api返回数据，设置超时，【使用前，注意绑定下对应模拟api的域名IP，不同的环境这个域名和IP不同】。</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/test%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="55-iflow-online阶段"><a class="markdownIt-Anchor" href="#55-iflow-online阶段"></a> 5.5、IFLOW — ONLINE阶段</h3>
<p>即上线至beta环境和GA环境，显示但前版本列表，支持一键回退功能【目前只是一个空架子】。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/online%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h2 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6、总结</h2>
<p>整体来说IFLOW开发测试流程管理系统只是一个<strong>流程框架或者外壳</strong>，后续相关的功能的模块都可以进行集成，将其形成一套完善的流程管理系统（整体页面功能可能会比较简陋，当时花费一个多月的闲余时间写的😀）。</p>
<p><strong>可集成功能：</strong></p>
<ul>
<li>**文档系统：**api文档、Wiki知识库</li>
<li>**测试用例系统：**测试编写用例，开发可以审核过测试用例等</li>
<li>**自动化测试系统：**测试自动化测试脚本</li>
<li>**代码管理平台：**可以直接检测代码质量，给代码评分等，比如 <a href="http://bbs.2345.net/d/169-sonarqube/3"><strong>sonarQube，可点击此查看</strong></a></li>
<li>**打包构建工具：**比如jekins（PHP你懂的，木有构建哦😂）</li>
<li><strong>CI可持续集成</strong></li>
<li><strong>发布系统</strong></li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>Iflow</category>
      </categories>
      <tags>
        <tag>Iflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins部署-K8s OR 物理机</title>
    <url>/2021/06/10/Jenkins/Jenkins%E9%83%A8%E7%BD%B2-K8sOR%E7%89%A9%E7%90%86%E6%9C%BA/</url>
    <content><![CDATA[<p>如果你开始使用Jenkins作为你的CI工具，刚好也在使用K8s集群做CD，那你一定很纠结我的Jenkins到底用什么方式进行部署管理呢？<br>
这里我将我们遇到的实际经验分享给各位参考，希望能给到你一些帮助吧，😄</p>
<span id="more"></span>
<h2 id="1-结论"><a class="markdownIt-Anchor" href="#1-结论"></a> 1、结论</h2>
<p>不拖沓，直接上结论：</p>
<p><strong>轻易不要上K8s</strong>，启动速度和Slave镜像管理以及构建缓存等会比较<code>耗精力</code>；在CICD起步，日构建在500次左右，特别是含Android的gradle构建时，建议直接上物理机，绝对<code>真香</code>。</p>
<blockquote>
<p>选择适合的，并不是技术领先的，当然能Hold住的大佬，请随意哈😁</p>
</blockquote>
<hr>
<p>备注说明下目前我遇到的构建量级吧，相对大厂是小儿科了点，勿喷哈。</p>
<ul>
<li>Web应用构建，约日均构建在400-500次/日</li>
<li>移动端构建（Android为主），约日均构建在30-50次/日，偶尔会有批量的渠道打包量比较大（渠道量1K+）</li>
</ul>
<h2 id="2-k8s集群里的jenkins"><a class="markdownIt-Anchor" href="#2-k8s集群里的jenkins"></a> 2、K8s集群里的Jenkins</h2>
<h3 id="21-选择背景"><a class="markdownIt-Anchor" href="#21-选择背景"></a> 2.1、选择背景</h3>
<p>公司开始做中台了，其中包括建设CICD系统，基本是从 O 起步吧，当初直接选型了：java spring微服务 + K8s作为接下来的技术发展方向。作为<code>打辅助</code>的持续交付系统也就那个时候定型的，选型CI工具为Jenkins（当然还有很多的周边的工具链选型），部署原则：<strong>Everything in docker</strong></p>
<h3 id="22-遇到问题"><a class="markdownIt-Anchor" href="#22-遇到问题"></a> 2.2、遇到问题</h3>
<ul>
<li>K8s集群稳定性是第一大考验</li>
<li>动态的Slave启动慢，修改长时间存活，莫名会出现心跳终端，SalvePod假死</li>
<li>各Slave节点构建依赖的缓存共享设置，尤其是移动端的Gradle的缓存（谁用谁知道！参考：<a href="https://blog.dreamtobe.cn/lls_ci/">流利说客户端持续交付工程实践</a>……）</li>
<li>Slave多了后占用的资源无法想象，最后不得不给Jenkins独立的Node，打上标签区分</li>
<li>还有就是构建过程，一个字儿：<strong>超级慢</strong>，很大原因是K8s集群的Ceph文件系统</li>
<li>Slave镜像维护成本也颇高，尤其是需要版本升级的时候</li>
<li>…</li>
</ul>
<h2 id="3-物理机里的jenkins"><a class="markdownIt-Anchor" href="#3-物理机里的jenkins"></a> 3、物理机里的Jenkins</h2>
<h3 id="31-选择背景"><a class="markdownIt-Anchor" href="#31-选择背景"></a> 3.1、选择背景</h3>
<p>我们重新建设了DevOps平台（定位：一站式研发协同平台），对于原有的功能迁移后，发现对于很多<code>核心、根本</code>问题，治标不治本。新平台也迫切需要出成绩，最终开出了 <code>历史的倒车</code>，我们回到了物理机Jenkins。</p>
<h3 id="32-效果"><a class="markdownIt-Anchor" href="#32-效果"></a> 3.2、效果</h3>
<p>一个字：<strong>快</strong>，平均提速达到30%+（其中移动端提速了甚至到了50%），且稳定性更高</p>
<h3 id="33-成本核算"><a class="markdownIt-Anchor" href="#33-成本核算"></a> 3.3、成本核算</h3>
<p>迁移到物理是不是成本很高啊，那可是物理机啊，然并卵……</p>
<table>
<thead>
<tr>
<th style="text-align:center">迁移前</th>
<th>迁移后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">K8s独立Node：64c+128G（1），32c+32G（1）</td>
<td>32c+32G（5）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins共享库使用-初级</title>
    <url>/2021/06/08/Jenkins/Jenkins%E5%85%B1%E4%BA%AB%E5%BA%93%E4%BD%BF%E7%94%A8-%E5%88%9D%E7%BA%A7/</url>
    <content><![CDATA[<p>在我们实际写Jenkin pipelines脚本中，可能会出现``java.lang.RuntimeException: Method code too large!<code>，这个时候你就要抽象出一些公共的函数类库，</code>避免项目方重复冗余的脚本代码书写`，在此处我也把我经常使用的一些共享函数库（<strong><a href="https://github.com/nengwu765/jenkins-share-library">jenkins-share-library</a></strong>）分享出来，欢迎交流指正哈！</p>
<span id="more"></span>
<h2 id="1-如何使用jenkins共享库"><a class="markdownIt-Anchor" href="#1-如何使用jenkins共享库"></a> 1. 如何使用Jenkins共享库</h2>
<ul>
<li>在Jenkinsfile的脚本文件第一行引入以下代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library &#x27;jenkins-shared-libraries&#x27;</span><br><span class="line"></span><br><span class="line">pipeline &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>调用示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage (&quot;demo&quot;) &#123;</span><br><span class="line">	steps &#123;</span><br><span class="line">		script &#123;</span><br><span class="line">			// 调用：共享方法名+入参</span><br><span class="line">			demoFunction(params1, params2, ...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-支持的共享库方法"><a class="markdownIt-Anchor" href="#2-支持的共享库方法"></a> 2. 支持的共享库方法</h2>
<h3 id="21-git仓库拉取-gitcodefetch"><a class="markdownIt-Anchor" href="#21-git仓库拉取-gitcodefetch"></a> 2.1 Git仓库拉取 - gitCodeFetch()</h3>
<p>支持基于分支/标签 和 Submodule子仓库拉取以及基于MR拉取分支，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/gitCodeFetch.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Git仓库版本拉取 -- 支持基于分支/标签 和 Submodule子仓库拉取以及基于MR拉取分支</span><br><span class="line"> *</span><br><span class="line"> * @param fetchMode Git代码拉取方式：branch-基于分支; tag-基于标签</span><br><span class="line"> * @param gitBranchOrTag Git仓库分支 或 标签</span><br><span class="line"> * @param gitRepository  Git仓库地址</span><br><span class="line"> * @param gitCredentialsId  Git拉取凭证ID 【若存在Submodule子仓库，则该凭证需要有子仓库拉取权限】</span><br><span class="line"> * @param gitEvent  git拉取事件,基于分支或Tag拉取,则置空; MergeRequest则为:&quot;MR&quot;</span><br><span class="line"> * @param targetBranch 若gitEvent为&quot;MR&quot;,此处为MR目标分支</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">void call(String fetchMode,String gitBranchOrTag, String gitRepository, String gitCredentialsId, String gitEvent = &#x27;&#x27;, String targetBranch = &#x27;&#x27;) </span><br></pre></td></tr></table></figure>
<h3 id="22-md5值校验-md5check"><a class="markdownIt-Anchor" href="#22-md5值校验-md5check"></a> 2.2 MD5值校验 - md5Check()</h3>
<p>文件MD5值check，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/md5Check.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件MD5值check</span><br><span class="line"> *</span><br><span class="line"> * @param filePath 文件路径</span><br><span class="line"> * @param md5 文件md5值</span><br><span class="line"> * @param forceCheck 是强制检查，是-必检，否-md5值非空则进行检查</span><br><span class="line"> */</span><br><span class="line">void md5Check(String filePath, String md5, boolean forceCheck = true)</span><br><span class="line"></span><br><span class="line">注：forceCheck=true时，校验不通过则报错，流水线终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23-sha1值校验-sha1check"><a class="markdownIt-Anchor" href="#23-sha1值校验-sha1check"></a> 2.3 SHA1值校验 - sha1Check()</h3>
<p>文件SHA1值check，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/sha1Check.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件SHA1值check</span><br><span class="line"> *</span><br><span class="line"> * @param filePath 文件路径</span><br><span class="line"> * @param sha1 文件md5值</span><br><span class="line"> * @param forceCheck 是强制检查，是-必检，否-md5值非空则进行检查</span><br><span class="line"> */</span><br><span class="line">void sha1Check(String filePath, String sha1, boolean forceCheck = true)</span><br><span class="line"></span><br><span class="line">注：forceCheck=true时，校验不通过则报错，流水线终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="24-ftp上传-ftpupload"><a class="markdownIt-Anchor" href="#24-ftp上传-ftpupload"></a> 2.4 FTP上传 - ftpUpload()</h3>
<p>FTP文件上传  – // 参数参考说明：<a href="https://jenkins.io/doc/pipeline/steps/publish-over-ftp">https://jenkins.io/doc/pipeline/steps/publish-over-ftp</a></p>
<p><a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/ftpUpload.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * FTP文件上传  -- // 参数参考说明：https://jenkins.io/doc/pipeline/steps/publish-over-ftp</span><br><span class="line"> * @param configName  在Jenkins全局设置的FTP Server名称</span><br><span class="line"> * @param sourceFiles  上传源文件，支持正则匹配，如[递归目录层级使用&#x27;**&#x27;]：&#x27;**/*.apk,public/**/*&#x27;</span><br><span class="line"> * @param remoteDir  上传子目录路径，注此路径会追加到全局设置的FTP Server的Remote Directory之后</span><br><span class="line"> * @param excludes  排除上传文件，支持正则匹配，如[递归目录层级使用&#x27;**&#x27;]： &#x27;**/*.log,**/*.tmp,.git/&#x27;</span><br><span class="line"> * @param removePrefix  去除上传文件的路径前缀，避免ftp服务器中生成无用的目录路径,注：所有上传文件必须都有该前缀，否则报错</span><br><span class="line"> */</span><br><span class="line">void ftpUpload(String configName, String sourceFiles, String remoteDir = &#x27;&#x27;, String excludes = &#x27;&#x27;, String removePrefix = &#x27;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="25-rsync-module远程同步-rsyncmodule"><a class="markdownIt-Anchor" href="#25-rsync-module远程同步-rsyncmodule"></a> 2.5 Rsync Module远程同步 - rsyncModule()</h3>
<p>rsync 使用Module远程同步，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/rsyncWithModule.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  rsync 使用Module远程同步</span><br><span class="line"> *</span><br><span class="line"> * @param ip rsync服务器IP</span><br><span class="line"> * @param port rsync服务器监听端口</span><br><span class="line"> * @param path rsync本地同步绝对路径</span><br><span class="line"> * @param module rsync同步模块</span><br><span class="line"> * @param user  rsync同步用户，指定传输文件为指定用户</span><br><span class="line"> * @param customParams 定制rsync参数，不允许出现&quot;delete&quot;关键字，如：--exclude=PATTERN --include=PATTERN --exclude-from=FILE --include-from=FILE</span><br><span class="line"> * @param bwlimit</span><br><span class="line"> */</span><br><span class="line">void rsyncModule(String ip, int port, String path, String module, String user = &#x27;&#x27;, String customParams = &#x27;&#x27;, int bwlimit = 8192)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="26-制品上传nexus-uploadartifactstonexus"><a class="markdownIt-Anchor" href="#26-制品上传nexus-uploadartifactstonexus"></a> 2.6 制品上传Nexus - uploadArtifactsToNexus()</h3>
<p>如果你是以Nexus作为制品库的话，这个可以作为参考，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/uploadArtifactsToNexus.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 上传制品至Nexus仓库</span><br><span class="line"> *</span><br><span class="line"> * @param nexusRepository Nexus上传仓库</span><br><span class="line"> * @param dir 检索目录</span><br><span class="line"> * @param fileMatchRegex 文件正则匹配规则， 支持文件类型、文件前缀、文件全名，</span><br><span class="line"> *        如文件：prefix_file.test,</span><br><span class="line"> *        匹配规则：</span><br><span class="line"> *              文件类型： fileMatchRegex = &quot;.test&quot;</span><br><span class="line"> *              文件前缀： fileMatchRegex = &quot;prefix_&quot;</span><br><span class="line"> *              文件全名： fileMatchRegex = &quot;prefix_file.test&quot;</span><br><span class="line"> * @param uploadSubPath 制品上传路经</span><br><span class="line"> * @param isRecursion 是否递归检索子目录,默认：否【注：同名文件会被覆盖】</span><br><span class="line"> * @param artifacts 制品存储数据，Map结构，默认：空Map</span><br><span class="line"> * @return Map 返回上传制品数据</span><br><span class="line"> *         eg: [</span><br><span class="line"> *              &#x27;file1&#x27;:[</span><br><span class="line"> *                  &#x27;url&#x27;:&#x27;https://nexus.demo.com/.../file1&#x27;  // 文件在nexus中的上传路径【即下载路径】</span><br><span class="line"> *                  &#x27;md5&#x27;:&#x27;xxxx&#x27; // 文件md5值</span><br><span class="line"> *                  &#x27;sha1&#x27;:&#x27;xxxx&#x27;   // 文件sha1值</span><br><span class="line"> *               ],</span><br><span class="line"> *         ]</span><br><span class="line"> */</span><br><span class="line">def uploadArtifactsToNexus(String nexusRepository, String dir, String fileMatchRegex, String uploadPath, boolean isRecursion = false, Map artifacts = [:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Android制品上传Nexus - uploadAndroidArtifacts()</li>
</ul>
<p><strong><code>针对Android制品上传，做了一层外围封装，防止不同业务上传仓库紊乱</code></strong>，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/uploadAndroidArtifacts.groovy">源码参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 上传制品至Nexus仓库</span><br><span class="line"> *</span><br><span class="line"> * @param dir 检索目录</span><br><span class="line"> * @param fileMatchRegex 文件正则匹配规则， 支持文件类型、文件前缀、文件全名，</span><br><span class="line"> *        如文件：prefix_file.test,</span><br><span class="line"> *        匹配规则：</span><br><span class="line"> *              文件类型： fileMatchRegex = &quot;.test&quot;</span><br><span class="line"> *              文件前缀： fileMatchRegex = &quot;prefix_&quot;</span><br><span class="line"> *              文件全名： fileMatchRegex = &quot;prefix_file.test&quot;</span><br><span class="line"> * @param uploadSubPath 制品上传路经</span><br><span class="line"> * @param isRecursion 是否递归检索子目录,默认：否【注：同名文件会被覆盖】</span><br><span class="line"> * @param artifacts 制品存储数据，Map结构，默认：空Map</span><br><span class="line"> * @return Map 返回上传制品数据</span><br><span class="line"> *         eg: [</span><br><span class="line"> *              &#x27;file1&#x27;:[</span><br><span class="line"> *                  &#x27;url&#x27;:&#x27;https://nexus.demo.com/.../file1&#x27;  // 文件在nexus中的上传路径【即下载路径】</span><br><span class="line"> *                  &#x27;md5&#x27;:&#x27;xxxx&#x27; // 文件md5值</span><br><span class="line"> *                  &#x27;sha1&#x27;:&#x27;xxxx&#x27;   // 文件sha1值</span><br><span class="line"> *               ],</span><br><span class="line"> *         ]</span><br><span class="line"> */</span><br><span class="line">def uploadAndroidArtifacts(String dir, String fileMatchRegex, String uploadPath, boolean isRecursion = false, Map artifacts = [:])</span><br></pre></td></tr></table></figure>
<h3 id="27-流水线结果回调-callbackaction"><a class="markdownIt-Anchor" href="#27-流水线结果回调-callbackaction"></a> 2.7 流水线结果回调 - callBackAction()</h3>
<p>Jenkins pipeline结果回调通知（这个其实有个Plugin支持，Job Notification，但是我觉得不够灵活），这边我自定义了一个通用回调，可以防止在任何位置，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/callBackAction.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 流水线执行结果回调操作</span><br><span class="line"> *</span><br><span class="line"> * @param callBackUrlsJson 回调Url地址Json数据</span><br><span class="line"> * @param artifacts 制品存储数据</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">void callBackAction(String callBackUrlsJson, Map artifacts = [:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">	agent any</span><br><span class="line"></span><br><span class="line">	stages &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">	post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            // 回调Api通知对接JOB执行结果</span><br><span class="line">            script &#123;</span><br><span class="line">                if (!binding.variables.containsKey(&quot;ARTIFACTS&quot;)) &#123;</span><br><span class="line">                    ARTIFACTS = [:]</span><br><span class="line">                &#125;</span><br><span class="line">                callBackAction(params.CALLBACK_URLS_JSON, ARTIFACTS)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            echo &quot;I will be executed while failed or succeed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-引用"><a class="markdownIt-Anchor" href="#5-引用"></a> 5 引用</h2>
<p><a href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/">官方参考，Extending with Shared Libraries</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JenkinsK8s集群部署AndroidSDK安装</title>
    <url>/2019/10/25/Mobile-CICD/JenkinsK8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2AndroidSDK%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>如过你的Jenkins是部署在K8s集群中的，那需要支持Android打包的情况。Android SDK安装与更新怎么做呢？<br>
<strong>本文将介绍在<code>K8s集群</code>中如何安装和更新 Android SDK</strong></p>
<span id="more"></span>
<h2 id="1-k8s集群中android-sdk安装与更新方案设计"><a class="markdownIt-Anchor" href="#1-k8s集群中android-sdk安装与更新方案设计"></a> 1. K8s集群中Android SDK安装与更新方案设计</h2>
<h3 id="11-android-sdk-tools镜像制作"><a class="markdownIt-Anchor" href="#11-android-sdk-tools镜像制作"></a> 1.1 Android SDK Tools镜像制作</h3>
<ul>
<li>使用Android SDK Tools</li>
</ul>
<p>Android在Jenkins中构建打包，只需要命令行工具即可（Command line tools only）。</p>
<p>只需安装Android SDK Tools，这是 Android SDK 的一个组件。它包含了 Android 的全套开发和调试工具，<a href="https://developer.android.google.cn/studio">在Android studios首页即可下载（位置：Command line tools only），点击进入</a>。</p>
<ul>
<li>使用<code>sdkmanager</code>进行工具管理</li>
</ul>
<p>使用 Android 的 <code>sdkmanager</code> 命令行工具进行查看、安装、更新和卸载 Android SDK 的软件包，<a href="https://developer.android.google.cn/studio/command-line/sdkmanager">sdkmanager工具介绍说明，点击进入</a></p>
<blockquote>
<p>注：<code>sdkmanager</code>工具在 Android SDK Tools 软件包（25.2.3 及更高版本）中提供，并位于 android_sdk/tools/bin/ 目录下，无需独立安装。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Android SDK Tools Dockerfile</span><br><span class="line">FROM harbor.demo.com/base/jre_centos:8u202_7.8</span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">ENV SDK_TOOLS_URL=&quot;https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip&quot; \</span><br><span class="line">    ANDROID_HOME=&quot;/opt/app/android-sdk&quot;</span><br><span class="line"></span><br><span class="line">RUN yum install -y zip unzip</span><br><span class="line">RUN mkdir -p &quot;$ANDROID_HOME&quot; .android \</span><br><span class="line">    &amp;&amp; cd &quot;$ANDROID_HOME&quot; \</span><br><span class="line">    &amp;&amp; curl -o sdk-tools.zip $SDK_TOOLS_URL \</span><br><span class="line">    &amp;&amp; unzip sdk-tools.zip \</span><br><span class="line">    &amp;&amp; rm sdk-tools.zip</span><br><span class="line">RUN yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses \</span><br><span class="line">    &amp;&amp; $ANDROID_HOME/tools/bin/sdkmanager --update</span><br><span class="line"></span><br><span class="line">#RUN $ANDROID_HOME/tools/bin/sdkmanager --install &quot;build-tools;29.0.1&quot; &quot;platforms;android-29&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="12-将android-sdk作为pvc挂载出来"><a class="markdownIt-Anchor" href="#12-将android-sdk作为pvc挂载出来"></a> 1.2 将Android sdk作为PVC挂载出来</h3>
<ul>
<li>
<p>k8s中申请50G的pvc挂载点</p>
</li>
<li>
<p>Android SDK Tools镜像挂载PVC</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装Android sdk工具</span><br><span class="line">sdkmanager --install XXX</span><br></pre></td></tr></table></figure>
<h3 id="13-android-sdk更新"><a class="markdownIt-Anchor" href="#13-android-sdk更新"></a> 1.3 Android SDK更新</h3>
<ul>
<li>使用cronjob重新发布一次即可</li>
</ul>
<p><strong><code>Cronjob更新稳定性不是很好，如果没有成功安装SDK工具，则可进入容器中，直接执行sdkmanager更新命令（cluster: cluster_pro 内网正式, namespace：jenkins，pod：androidsdk-xxxxx）</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// cronjob的部署示例：</span><br><span class="line">jobs:</span><br><span class="line">- name: androidsdk-job</span><br><span class="line">  # job运行环境集群，和 global.env 的值对应</span><br><span class="line">  runEnv:</span><br><span class="line">  - dev</span><br><span class="line">  - test</span><br><span class="line">  - pdt</span><br><span class="line">  image:</span><br><span class="line">     repository: harbor.demo.com/cicd/android-sdk-tools</span><br><span class="line">     tag: v0.0.1</span><br><span class="line">     pullPolicy: Always</span><br><span class="line">  command:</span><br><span class="line">  - &quot;/opt/app/android-sdk-v/tools/bin/sdkmanager&quot;</span><br><span class="line">  - &quot;--install&quot;</span><br><span class="line">  args:</span><br><span class="line">#### ./sdkmanager --list sdk包 ####</span><br><span class="line">#  - &quot;build-tools;19.1.0&quot;</span><br><span class="line">#  - &quot;build-tools;20.0.0&quot;</span><br><span class="line">#  - &quot;build-tools;21.1.2&quot;</span><br><span class="line">#  - &quot;build-tools;22.0.1&quot;</span><br><span class="line">#  - &quot;build-tools;23.0.1&quot;</span><br><span class="line">#  - &quot;build-tools;23.0.2&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-k8s集群中android-sdk安装与更新"><a class="markdownIt-Anchor" href="#14-k8s集群中android-sdk安装与更新"></a> 1.4 K8s集群中Android SDK安装与更新</h3>
<ul>
<li>使用Helm进行部署和更新，此处我们使用的是Helm方式部署的（有关Helm的部署，将后续分享……）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO chart部署仓库</span><br></pre></td></tr></table></figure>
<h2 id="2-jenkins-slave节点使用android-sdk工具"><a class="markdownIt-Anchor" href="#2-jenkins-slave节点使用android-sdk工具"></a> 2 Jenkins slave节点使用Android SDK工具</h2>
<ul>
<li>配置Jenkins slave节点</li>
</ul>
<p>添加一个环境变量和挂载卷</p>
<p><img src="/2019/10/25/Mobile-CICD/JenkinsK8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2AndroidSDK%E5%AE%89%E8%A3%85/jenkins%E9%85%8D%E7%BD%AE.png" alt="Jenkins配置"></p>
<ul>
<li>Jenkinsfile中使用</li>
</ul>
<p>直接使用对应Jenkins slave节点，执行gradle命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    // 全局执行代理</span><br><span class="line">    agent &#123;</span><br><span class="line">        kubernetes &#123;</span><br><span class="line">            cloud &#x27;kubernetes&#x27;</span><br><span class="line">            label &#x27;label-gradle&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	stages &#123;</span><br><span class="line">        stage (&quot;gradle构建&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &quot;./gradlew clean &quot; +</span><br><span class="line">                        &quot;channelRelease --stacktrace &quot; +</span><br><span class="line">                        &quot;-PBUILD_NUMBER=$&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>移动CICD</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>移动CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(一)-工具选型</title>
    <url>/2021/05/27/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%80)-%E5%B7%A5%E5%85%B7%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>DevOps必不可少的一环就是代码扫描了，这里面包含了编码规范、代码缺陷、性能、漏洞的检测。目前也会有很多的开源静态代码扫描工具，如：SonarQube、Infer、PMD、FindBugs、CheckStyle。针对此做了简单的收集对比，各位可以根据自身的需求进行参考。</p>
<span id="more"></span>
<h2 id="工具选型调研"><a class="markdownIt-Anchor" href="#工具选型调研"></a> 工具选型调研</h2>
<h3 id="工具对比说明"><a class="markdownIt-Anchor" href="#工具对比说明"></a> 工具对比说明</h3>
<p>目前比较流行的开源的静态代码扫描工具：SonarQube、Infer、PMD、FindBugs、CheckStyle。因为后续会有流程定制化等需求，暂不考虑商业化的软件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">产品</th>
<th style="text-align:center">定位</th>
<th style="text-align:left">OpenApi</th>
<th style="text-align:left">Web项目友好</th>
<th style="text-align:left">支持代码质量检查</th>
<th style="text-align:left">支持语言</th>
<th style="text-align:left">可扩展性/插件支持</th>
<th style="text-align:left">是否侵入项目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SonarQube</td>
<td style="text-align:center">代码质量平台 <br>通过插件的<br>方式提供对各个<br>语言进行支持，<br>可以和 Checkstyle、PMD、Simian <br>等工具进行集成</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">常见语言都支持</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">Infer</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">否（移动端友好）</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">Android/java</td>
<td style="text-align:left">中</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">PMD</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">FindBugs</td>
<td style="text-align:center">字节码分析，侧重Bug检测</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">CheckStyle</td>
<td style="text-align:center">语法层面分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<h3 id="选型"><a class="markdownIt-Anchor" href="#选型"></a> 选型</h3>
<p>基于上述，<strong>选型SonarQube作为代码扫描工具</strong>，SonarQube 也是是一款目前比较流行的工具，国内很多互联网公司都选择用它来搭建静态检查的平台。</p>
<p>SonarQube介绍: <a href="https://www.sonarqube.org/">官网</a></p>
<h2 id="实施计划"><a class="markdownIt-Anchor" href="#实施计划"></a> 实施计划</h2>
<ul>
<li>SonarQube的部署使用调研</li>
<li>代码检测集成方案，（Jenkins、gitlab CI、代码检测时机等）</li>
<li>考虑代码质量平台管理（原生平台界面不友好、同时展示维度无法做到应用维度）</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> <strong>参考资料</strong></h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">资料</th>
<th style="text-align:left">概述</th>
<th style="text-align:left">参考价值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://testerhome.com/articles/24210">酷家乐质量效能 代码度量平台</a></td>
<td style="text-align:left">引入使用 SQALE 代码质量评估模型的 SonarQube 进行代码静态扫描，辅以 Cobra 的进行代码审计，Synk 进行三方包漏洞扫描，形成一套完整的代码度量工具链</td>
<td style="text-align:left"><strong>高</strong><br>整合平台页面参考</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://mp.weixin.qq.com/s/d9RzCFkYrW27m1_LkeA2rw">系列 | 58集团白盒代码审计系统建设实践1：技术选型</a></td>
<td style="text-align:left">对比了常见的的开源方案和商业方案，同时涉及介绍 SDL 相关检测知识</td>
<td style="text-align:left"><strong>高</strong><br>选型对比数据参考</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(三)-Sonar+Jenkins+Gitlab集成</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%89)-Sonar+Jenkins+Gitlab/</url>
    <content><![CDATA[<p>目前我们使用CI工具主要是Jenkins，所以此相互选择了jenkins进行集成。根据实际情况，也可选择GitlabCI等工具。</p>
<p>实施代码检测，Gitlab 代码变更（Push/Merge），触发Jenkins Job执行SonarScanner扫描代码，SonarServer通过Gitlab插件，将代码扫描完的结果回写至Gitlab，GitLab即可查看到对应Sonar检测的结果代码注释，方便开发人员代码排查</p>
<span id="more"></span>
<h2 id="实现目的"><a class="markdownIt-Anchor" href="#实现目的"></a> 实现目的</h2>
<ul>
<li>1、研发过程，Jenkins在构建过程，加入SonarQube的代码质量门，检测本次构建增量代码质量</li>
<li>2、定期的全量代码质量扫描，在每周定期对公司所有代码进行全量扫描，产出代码质量报告</li>
</ul>
<h2 id="集成插件配置"><a class="markdownIt-Anchor" href="#集成插件配置"></a> 集成插件配置</h2>
<h3 id="1-jenkins插件配置"><a class="markdownIt-Anchor" href="#1-jenkins插件配置"></a> 1、Jenkins插件&amp;配置</h3>
<p><strong>插件：</strong></p>
<ul>
<li>SonarQubeScannerForJenkins</li>
</ul>
<p><strong>配置：</strong></p>
<ul>
<li>SonarServer配置：Manage Jenkins – &gt; Configure System – &gt; SonarQube servers<br>
需要SonarQube基于高权限账号生成的 授权token （SonarQube：Administration – &gt; Security – &gt; Users）</li>
<li>SonarScanner配置：Manage Jenkins – &gt; Global Tool Configuration – &gt; SonarQube Scanner<br>
备注：<strong>这里安装多个SonarQube Scanner，为多项目并行代码扫描做准备</strong></li>
</ul>
<h3 id="2-sonarqube配置"><a class="markdownIt-Anchor" href="#2-sonarqube配置"></a> 2、SonarQube配置</h3>
<p><strong>插件：</strong></p>
<p>实现gitlab打通，<strong>同时实现gitlab auth授权登陆</strong>。</p>
<ul>
<li>sonar-gitlab-plugin：<a href="https://github.com/javamachr/sonar-gitlab-plugin">https://github.com/javamachr/sonar-gitlab-plugin</a></li>
<li>**sonar-auth-gitlab-plugin：**<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin</a></li>
</ul>
<p>**Sonar Serverbase Url设置：**Administration &gt; Configuration &gt; General&gt; Server base URL</p>
<p><strong>Webhook配置：（实操，不配置，JEnkins在获取质量门结果时会无限等待）</strong></p>
<p>Administration &gt; Configuration &gt; Webhooks. The URL should point to your Jenkins server： <code>http://&#123;JENKINS_HOST&#125;/sonarqube-webhook/</code></p>
<p>具体说明：参考Jenkins官方文档说明（<a href="https://www.jenkins.io/doc/pipeline/steps/sonar/#waitforqualitygate-wait-for-sonarqube-analysis-to-be-completed-and-return-quality-gate-status">Configure a webhook in your SonarQube server pointing</a> … ）</p>
<p><strong>Gitlab授权登陆：</strong></p>
<p>Administration &gt; Configuration &gt; GitLab &gt; Authentication ：设置对应的 Application ID + Secret</p>
<p>(设置参数说明，参考对应的插件说明：<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">sonar-auth-gitlab-plugin</a>)</p>
<p><strong>Gitlab Reporting配置：</strong></p>
<ul>
<li>
<p>作用：可以将检测结果报告已comment的形式回写至Gitlab的Commit中（注：目前版本不支持inline comment in commit，现在只有global comment，具体看附属问题记录说明）</p>
</li>
<li>
<p>配置：Administration &gt; Configuration &gt; GitLab &gt; Reporting</p>
</li>
<li>
<p>参数：扫描时需要配置参数：sonar.gitlab.project_id</p>
</li>
</ul>
<p>说明：这个可以根据实际需求配置说明，此处可根据需求配置将检测的结果是否以comment回写。此处暂时不配置。</p>
<h3 id="3-gitlab配置"><a class="markdownIt-Anchor" href="#3-gitlab配置"></a> 3、Gitlab配置</h3>
<p><strong>授权登陆设置：</strong><br>
Admin Settings -&gt; Application：设置对应的回调：https://<your sonar domain>/oauth2/callback/gitlab (备注：sonar的domain不可为IP+Port形式，经测试http目前也是支持)</your></p>
<h2 id="问题记录"><a class="markdownIt-Anchor" href="#问题记录"></a> 问题记录</h2>
<ul>
<li>SonarCloud + GitHub + Pull Request Analysis = No Inline Comments：<a href="https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2">https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2</a><br>
目前最后支持的版本：sonarqube v7.6</li>
<li>新扫描项目（新sonar project key） No branches currently exist in this project. Please scan the main branch without passing any branch parameters<br>
注：新项目必须先扫描 master（稳定）分支，才可以进行其他分支的扫描</li>
<li>不建议写入sonar.language扫描参数： <a href="https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993">https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993</a></li>
<li>SonarQube插件矩阵（可查看相关产检兼容情况）：<a href="https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/">https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(二)-SonarQube安装</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%BA%8C)-SonarQube%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>SonarQube的安装会给予版本有些差异，建议根据你选择的版本结合官方的文档进行安装，中间遇到问题再自行Google一下啦。本文主要是讲解一下版本的安装：SonarQube：7.9 LTS +PostgreSQL 10</p>
<span id="more"></span>
<h2 id="版本选择"><a class="markdownIt-Anchor" href="#版本选择"></a> 版本选择</h2>
<p>不同的版本对应的插件选择和数据库支持不同，同时需要考虑版本的稳定性。考虑稳定性，避免出现问题无法跟进处理解决，生产环境不考虑最新版本。</p>
<p>SonarQube：7.9 LTS</p>
<p>SonarQube v7.9 的前置依赖说明（<a href="https://docs.sonarqube.org/7.9/requirements/requirements/%EF%BC%89">https://docs.sonarqube.org/7.9/requirements/requirements/）</a></p>
<ul>
<li>数据库：PostgreSQL 10</li>
<li>Java JDK：OpenJDK 11</li>
</ul>
<h2 id="安装说明"><a class="markdownIt-Anchor" href="#安装说明"></a> 安装说明</h2>
<h3 id="1-openjdk-11安装"><a class="markdownIt-Anchor" href="#1-openjdk-11安装"></a> 1、OpenJDK 11安装</h3>
<p>官方安装引导：<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a></p>
<p>安装包（Linux/x64）：（<a href="https://download.java.net/openjdk/jdk11/ri/openjdk-11+28_linux-x64_bin.tar.gz">官方下载</a> ）</p>
<p><strong>解压缩</strong></p>
<p>&gt; tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz</p>
<p><strong>配置环境变量</strong></p>
<p>&gt; 末尾增加如下内容(根据自己jdk目录修改)：<br>
&gt; export JAVA_HOME=/usr/local/jdk-11<br>
&gt; export CLASSPATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/lib:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>CLASSPATH<br>
&gt; export PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>i</mi><mi>n</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/bin:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>PATH</p>
<p><strong>验证</strong></p>
<p>&gt; java -version</p>
<h3 id="2-postgresql-10安装"><a class="markdownIt-Anchor" href="#2-postgresql-10安装"></a> 2、PostgreSQL 10安装</h3>
<p>官方的安装引导：<a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></p>
<ul>
<li>Select version：10</li>
<li>Select platform：CentOS 7</li>
<li>Select architecture: x86_64</li>
</ul>
<p>执行安装脚本及初始化启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装repo源</span></span><br><span class="line">sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装服务端</span></span><br><span class="line">sudo yum install -y postgresql10-server</span><br><span class="line"> </span><br><span class="line"><span class="comment"># PGsql进行初始化</span></span><br><span class="line">sudo /usr/pgsql-10/bin/postgresql-10-setup initdb</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加入开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启动PGsql</span></span><br><span class="line">stl start postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status postgresql-10.service</span><br></pre></td></tr></table></figure>
<p>初始化SonarQube使用的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接到数据库</span></span><br><span class="line">psql</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">CREATE DATABASE sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER sonarqube WITH PASSWORD <span class="string">&#x27;xxxxx&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE sonarqube TO sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建授权（必须）</span></span><br><span class="line">ALTER DATABASE sonarqube owner to sonarqube;</span><br></pre></td></tr></table></figure>
<p>修改pg数据的pg_hba.conf（<a href="http://www.postgres.cn/docs/10/auth-pg-hba-conf.html"><code>pg_hba.conf</code>文件说明</a>）将认证 ident 改为 md5，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># &quot;local&quot; is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all             all                                     peer</span><br><span class="line"><span class="comment"># IPv4 local connections:</span></span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line"><span class="comment"># IPv6 local connections:</span></span><br><span class="line">host    all             all             ::1/128                 md5</span><br><span class="line"><span class="comment"># Allow replication connections from localhost, by a user with the</span></span><br><span class="line"><span class="comment"># replication privilege.</span></span><br><span class="line"><span class="comment">#local   replication     postgres                                peer</span></span><br><span class="line"><span class="comment">#host    replication     postgres        127.0.0.1/32            ident</span></span><br><span class="line"><span class="comment">#host    replication     postgres        ::1/128                 ident</span></span><br><span class="line"><span class="comment">#host    replication     sonar           127.0.0.1/32            ident</span></span><br></pre></td></tr></table></figure>
<h3 id="3-sonarqube-79安装"><a class="markdownIt-Anchor" href="#3-sonarqube-79安装"></a> 3、SonarQube 7.9安装</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/setup/install-server/">https://docs.sonarqube.org/7.9/setup/install-server/</a></p>
<p>安装包：（<a href="https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.9.6.zip">官方下载</a>）</p>
<p><strong>创建sonar用户</strong></p>
<p>&gt; sudo useradd sonar</p>
<p>&gt; passwd sonar (密码：xxxx)</p>
<p>linux平台文件数限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置系统最大文件数</span></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">sysctl -w fs.file-max=65536</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置sonar用户再打文件数 文件：/etc/security/limits.d/99-sonarqube.conf (or /etc/security/limits.conf as you wish)，注：终端需退出重登生效或source后生效？</span></span><br><span class="line">sonar -   nofile   65536</span><br><span class="line">sonar -   nproc    4096</span><br></pre></td></tr></table></figure>
<p><strong>安装配置</strong></p>
<ul>
<li>数据库链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.jdbc.username=sonarqube</span><br><span class="line">&gt; sonar.jdbc.password=mypassword</span><br><span class="line">&gt; sonar.jdbc.url=jdbc:postgresql://localhost/sonarqube</span><br></pre></td></tr></table></figure>
<ul>
<li>ES存储</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.path.data=/opt/data/sonarqube/data</span><br><span class="line">&gt; sonar.path.temp=/opt/data/sonarqube/temp</span><br></pre></td></tr></table></figure>
<ul>
<li>Web Server配置</li>
</ul>
<p>自己设定启动端口配置即可</p>
<p><strong>脚本启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="variable">$&#123;sonar_home&#125;</span>/bin/linux-x86-64/sonar.sh start</span><br></pre></td></tr></table></figure>
<p>服务器部署，注意加入到开机启动项中,，此处我是加入 rc.local 文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sonarqube server</span></span><br><span class="line">su - sonar -c <span class="string">&quot;/opt/app/sonarqube/sonarqube-7.9.6/bin/linux-x86-64/sonar.sh start&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-sonarqube-scanner"><a class="markdownIt-Anchor" href="#4-sonarqube-scanner"></a> 4、SonarQube Scanner</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/</a></p>
<p>安装包：（<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">官方下载</a>）</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置SonarQube Server，位置：$install_directory/conf/sonar-scanner.properties</span></span><br><span class="line"><span class="comment">#----- Default SonarQube server</span></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将$install_directory/bin，加入到环境变量PATH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 sonar-scanner -h ，做验证</span></span><br></pre></td></tr></table></figure>
<p>**每个扫描项目的根目录加入：**sonar-project.properties</p>
<p>sonar-project.properties示例： <a href="https://github.com/SonarSource/sonar-scanning-examples">browsed</a> or <a href="https://github.com/SonarSource/sonar-scanning-examples/archive/master.zip">downloaded</a></p>
<h3 id="5-sonarqube-plugin"><a class="markdownIt-Anchor" href="#5-sonarqube-plugin"></a> 5、SonarQube Plugin</h3>
<ul>
<li>社区版支持多分支检测： <a href="https://github.com/mc1arke/sonarqube-community-branch-plugin">sonarqube-community-branch-plugin</a>（1.3.2老版本，安装<a href="https://github.com/mc1arke/sonarqube-community-branch-plugin/commit/a6b6db3f30e1ebba7183825542d1f5363b66a831#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5">区别现说明</a>：Copy the plugin JAR file to the <code>extensions/plugins/</code> <strong>and</strong> the <code>lib/common/</code> directories of your SonarQube instance and restart SonarQube）</li>
<li>汉化包（不建议，总觉得怪怪的）：直接在应用市场检索按照对应的版本即可（jar插件下载：<a href="https://github.com/xuhuisheng/sonar-l10n-zh">sonar-l10n-zh</a>）</li>
</ul>
<h3 id="6-相关配置"><a class="markdownIt-Anchor" href="#6-相关配置"></a> 6、相关配置</h3>
<ul>
<li><strong>解决增量代码小于20行，QG不生效情况：</strong></li>
</ul>
<p>&gt; 配置：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<h2 id="问题记录"><a class="markdownIt-Anchor" href="#问题记录"></a> 问题记录</h2>
<p><strong>1、Some Quality Gate conditions on New Code were ignored because of the small number of New Lines</strong></p>
<p>但分支模式增量代码扫描，少于20行时，代码坏味道无法检测到，可以参考：<a href="https://jira.sonarsource.com/browse/SONAR-9352">SONAR-9352</a> 或 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a></p>
<p>解决：解决方案说明参考 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a>，</p>
<p>步骤：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<p><strong>2、the main branch has no lines of code</strong></p>
<p>扫描php，遇到的错误，主要原因是唯一的php的文件在解析阶段就出现错误，无法正常解析，也就没有扫描文件，更没有扫描结果了。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ol>
<li><a href="https://bbs.huaweicloud.com/blogs/159762">SonarQube安装及踩坑体验</a></li>
<li><a href="https://blog.csdn.net/CN_TangZheng/article/details/109244806">调研sonarqube版本区别</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1732805">从零开始针对 .NET 应用的 DevOps 运营实践 - Jenkins &amp; SonarQube 安装配置</a></li>
</ol>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Pipeline语法详解</title>
    <url>/2021/05/27/Jenkins/Jenkins%20Pipeline%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>如何编写流水线文件jenkinsfile呢？其实其重点是使用<code>Pipeline语法</code>。 所以此处将重点介绍如何使用Pipeline的语法，从Pipeline插件2.5版开始，Pipeline支持两种独立的语法结构：<strong>Declarative Pipeline</strong> 和 <strong>Scripted Pipeline</strong>，两者都支持建立连续传送的Pipeline。</p>
<span id="more"></span>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h2>
<p>先说下最后的选择吧，为与BlueOcean编辑器兼容，<code>建议使用Declarative Pipeline的方式进行编写</code>,这种语法结构也会是Jenkins Pipeline未来发展的趋势。</p>
<h2 id="2-declarative-pipeline"><a class="markdownIt-Anchor" href="#2-declarative-pipeline"></a> 2 Declarative Pipeline</h2>
<p>从Pipeline2.5版本以后，Jenkins Pipeline新增了一种新的语法类型Declarative Pipeline（声明式Pipeline），它在Pipeline系统之上提供了一种更加简单和有意义的语法。</p>
<p>所有有效的Declarative Pipeline必须包含在一个pipeline块内，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123; </span><br><span class="line"><span class="comment">/* insert Declarative Pipeline here */</span> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Declarative Pipeline遵循与Groovy相同的语法规则，但有以下几点例外：</p>
<ul>
<li>
<p>Pipeline的顶层必须是块，具体来说就是：pipeline { }。</p>
</li>
<li>
<p>不用分号作为语句分隔符，每个声明必须独立一行。</p>
</li>
<li>
<p>块里只能包含Sections（章节）、Directives（指令）、 Steps（步骤）或赋值语句。</p>
</li>
<li>
<p>属性引用以无参方法的方式调用。例如，输入被视为input（）。</p>
</li>
</ul>
<h3 id="21-sections章节"><a class="markdownIt-Anchor" href="#21-sections章节"></a> 2.1 Sections（章节）</h3>
<p>Declarative Pipeline里的Sections通常包含一个或多个Directives或Steps。</p>
<h4 id="agent"><a class="markdownIt-Anchor" href="#agent"></a> agent</h4>
<p>agent指定整个Pipeline或特定stage在Jenkins环境中执行的位置。在pipeline代码块的顶层agent必须进行定义，但在stage级使用是可选的。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">见参数说明</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="参数列表"><a class="markdownIt-Anchor" href="#参数列表"></a> 参数列表</h5>
<p>为实现Pipeline可能拥有的各种用例，agent支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p>
<p><strong>any</strong></p>
<p>在任何可用的agent 上执行Pipeline或stage。例如：agent any<br>
<strong>none</strong></p>
<p>当在pipeline块的顶层使用none时，将不会为整个Pipeline运行分配全局agent ，每个stage部分将需要定义其自己的agent。</p>
<p><strong>label</strong></p>
<p>提供label标签名称，在Jenkins环境中可用的agent上执行Pipeline或stage。</p>
<p>例如：agent { label ‘my-defined-label’ }</p>
<p><strong>node</strong></p>
<p>agent { node { label ‘labelName’ } }，等同于 agent { label ‘labelName’ }，但node也允许其他选项（如customWorkspace）。</p>
<p><strong>docker</strong></p>
<p>定义此参数时，执行Pipeline或stage时会动态提供一个docker节点去运行基于Docker的Pipelines。docker还可以接受一个args参数，直接传递给docker run指令调用。</p>
<p>例如：agent { docker ‘maven:3-alpine’ }或</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        image <span class="string">&#x27;maven:3-alpine&#x27;</span></span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        args  <span class="string">&#x27;-v /tmp:/tmp&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>dockerfile</strong></p>
<p>使用从Dockerfile仓库中包含的dockerfile创建镜像文件来构建执行Pipeline或stage。为了使用此选项，Jenkinsfile必须从Multibranch Pipeline或“Pipeline from SCM&quot;中加载。</p>
<p>默认目录是在Dockerfile仓库的根目录：agent { dockerfile true }。如果Dockerfile需在另一个目录中建立，可使用dir选项：agent { dockerfile { dir ‘someSubDir’ } }。</p>
<p>还可以通过docker build …使用additionalBuildArgs选项，如agent { dockerfile { additionalBuildArgs ‘–build-arg foo=bar’ } }。</p>
<h5 id="通用选项"><a class="markdownIt-Anchor" href="#通用选项"></a> 通用选项</h5>
<p>这些是可以应用于两个或多个agent中的选项。除非明确定义，否则非必需。</p>
<p><strong>label</strong></p>
<p>string字符串。标记在哪里运行pipeline或stage</p>
<p>此选项适用于node，docker和dockerfile，并且在node中是必需的。<br>
<strong>customWorkspace</strong></p>
<p>string字符串。自定义运行的工作空间,它可以是相对路径，在这种情况下，自定义工作区将位于node节点工作空间的根目录下，也可以是绝对路径。例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    node &#123;</span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        customWorkspace <span class="string">&#x27;/some/other/path&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reuseNode</strong><br>
一个布尔值，默认为false。如果为true，则在同一工作空间中，此选项适用于docker和dockerfile，并且仅在独立stage中使用agent时才有效。</p>
<h5 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn -B clean verify&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>使用‘maven:3-alpine’的镜像创建容器，执行pipeline的所有步骤。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent none ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ②</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, Maven&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Test&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;openjdk:8-jre&#x27;</span> &#125; ③</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, JDK&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;java -version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>agent none在Pipeline顶层定义，表示将不会为整个Pipeline运行分配全局agent，每个stage需自己设置agent。</p>
<p><strong>②</strong>使用‘maven:3-alpine’的镜像创建容器，执行此阶段中的步骤。</p>
<p><strong>③</strong>使用‘openjdk:8-jre’的镜像创建容器，执行此阶段中的步骤。</p>
<h4 id="post"><a class="markdownIt-Anchor" href="#post"></a> post</h4>
<p>定义Pipeline或stage运行结束后的操作。post支持以下类型的代码块：always，changed，failure，success，unstable和aborted。这些代码块允许在Pipeline或stage运行结束时执行相关步骤，具体取决于Pipeline的运行状态。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-2"><a class="markdownIt-Anchor" href="#参数列表-2"></a> 参数列表</h5>
<p><strong>always</strong></p>
<p>结束时运行，无论Pipeline运行的完成状态如何。</p>
<p><strong>changed</strong></p>
<p>只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能运行。</p>
<p><strong>failure</strong></p>
<p>只有当前Pipeline处于“失败”状态时才运行，通常用红色指示的Web UI表示。</p>
<p><strong>success</strong></p>
<p>只有当前Pipeline具有“成功”状态时才运行，通常用蓝色或绿色指示的Web UI表示。</p>
<p><strong>unstable</strong></p>
<p>只有当前Pipeline具有“不稳定”状态，一般由测试失败，代码违例等引起，才能运行。通常用黄色指示的Web UI表示。</p>
<p><strong>aborted</strong></p>
<p>只有当前Pipeline处于“中止”状态时，才会运行，通常是由于Pipeline被手动中止。通常用灰色指示的Web UI表示。</p>
<h5 id="样例-2"><a class="markdownIt-Anchor" href="#样例-2"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">&#x27;I will always say Hello again!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①post章节通常会放在pipeline末端。</p>
<p>②post代码块里包括steps章节的内容。</p>
<h4 id="stages"><a class="markdownIt-Anchor" href="#stages"></a> stages</h4>
<p>包含一个或多个stage的序列，Pipeline的大部分工作在此执行。建议stages至少包含至少一个stage指令，用于连接各个交付过程，如构建，测试和部署等。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-3"><a class="markdownIt-Anchor" href="#样例-3"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>stages章节通常跟随在agent,options等指令后面。</p>
<h4 id="steps"><a class="markdownIt-Anchor" href="#steps"></a> steps</h4>
<p>steps包含一个或多个在stage块中执行的step序列。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在每个stage代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-4"><a class="markdownIt-Anchor" href="#样例-4"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; </span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;①</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>① steps章节必须包括一个或多个step。</strong></p>
<h3 id="22-directives-指令"><a class="markdownIt-Anchor" href="#22-directives-指令"></a> 2.2 Directives （指令）</h3>
<h4 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> environment</h4>
<p>environment指令指定一系列键值对，这些键值对将被定义为所有step或stage中step的环境变量，具体取决于environment指令在Pipeline中的位置。</p>
<p>该指令支持一种特殊的方法credentials()，可通过标识符访问Jenkins环境中预定义好的Credential凭证。</p>
<p>对于“Secret Text”类型的凭据，credentials()方法需确保指定的环境变量包含Secret Text内容，对于“Standard username and password&quot;”类型的凭证，指定的环境变量需要设置为username:password。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-5"><a class="markdownIt-Anchor" href="#样例-5"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">environment</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">&#x27;clang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">&#x27;my-prefined-secret-text&#x27;</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;printenv&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>environment指令放在pipeline顶级块中，将适用pipeline所有步骤。</p>
<p><strong>②</strong>environment指令放在stage中，给定的环境变量将只适用该stage中的步骤。</p>
<p><strong>③</strong>environment块中使用credentials()方法，可以访问Jenkins环境中预定义的凭证。</p>
<h4 id="options"><a class="markdownIt-Anchor" href="#options"></a> options</h4>
<p>options指令允许在Pipeline内配置Pipeline专用选项。Pipeline本身提供了许多选项，例如buildDiscarder，它们也可以由Jenkins插件提供，例如 timestamps。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-3"><a class="markdownIt-Anchor" href="#参数列表-3"></a> 参数列表</h5>
<p><strong>buildDiscarder</strong></p>
<p>pipeline保持构建的最大个数。例如：</p>
<p>options{buildDiscarder(logRotator(numToKeepStr: ‘1’))}</p>
<p><strong>disableConcurrentBuilds</strong></p>
<p>不允许并行执行Pipeline,可用于防止同时访问共享资源等。例如：</p>
<p>options {disableConcurrentBuilds()}</p>
<p><strong>skipDefaultCheckout</strong></p>
<p>默认跳过来自源代码控制的代码。例如：</p>
<p>options {skipDefaultCheckout()}</p>
<p><strong>skipStagesAfterUnstable</strong></p>
<p>一旦构建状态进入了“Unstable”状态，就跳过此stage。例如：</p>
<p>options {skipStagesAfterUnstable()}</p>
<p><strong>timeout</strong><br>
设置Pipeline运行的超时时间。例如：</p>
<p>options {timeout(time: 1, unit: ‘HOURS’)}F</p>
<p><strong>retry</strong></p>
<p>失败后，重试整个Pipeline的次数。例如：</p>
<p>options {retry(3)}</p>
<p><strong>timestamps</strong></p>
<p>预定义由Pipeline生成的所有控制台输出时间。例如：</p>
<p>options {timestamps()}</p>
<h5 id="样例-6"><a class="markdownIt-Anchor" href="#样例-6"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123; </span><br><span class="line">        timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>) ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>设置pipeline全局的超时时间为1小时，超时后将会自动终止pipeline运行。</p>
<h4 id="parameters"><a class="markdownIt-Anchor" href="#parameters"></a> parameters</h4>
<p>parameters指令提供用户在触发Pipeline时的参数列表。这些参数值通过params对象可用于Pipeline步骤，具体用法如下</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-4"><a class="markdownIt-Anchor" href="#参数列表-4"></a> 参数列表</h5>
<p><strong>string</strong></p>
<p>string类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123; </span><br><span class="line">string(<span class="attr">name:</span> <span class="string">&#x27;DEPLOY_ENV&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;staging&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>booleanParam</strong></p>
<p>boolean类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123;</span><br><span class="line"> booleanParam(<span class="attr">name:</span> <span class="string">&#x27;DEBUG_BUILD&#x27;</span>, <span class="attr">defaultValue:</span> <span class="literal">true</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截至发稿，Jenkins社区目前已支持[booleanParam, choice, credentials, file, text, password, run, string]这几种参数类型，其他高级参数化类型也在陆续完善中。</p>
<h5 id="样例-7"><a class="markdownIt-Anchor" href="#样例-7"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="attr">name:</span> <span class="string">&#x27;PERSON&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;Mr Jenkins&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Who should I say hello to?&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Hello $&#123;params.PERSON&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggers"><a class="markdownIt-Anchor" href="#triggers"></a> triggers</h4>
<p>triggers指令定义了Pipeline自动化触发的方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成也已经存在。目前只有两个可用的触发器：cron、pollSCM和upstream。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<p><strong>cron</strong></p>
<p>接受一个cron风格的字符串来定义Pipeline触发的常规间隔，例如：</p>
<p>triggers {cron(‘H 4/* 0 0 1-5’)}</p>
<p><strong>pollSCM</strong><br>
接受一个cron风格的字符串来定义Jenkins检查SCM源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers {pollSCM(‘H 4/* 0 0 1-5’)}</p>
<p><strong>upstream</strong></p>
<p>可接受多个job名称以及一个threshold设置参数。任何一个job以符合threshold条件完成后，均可以触发Pipeline的运行。举例：{ upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p>
<h5 id="样例-8"><a class="markdownIt-Anchor" href="#样例-8"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">&#x27;H 4/* 0 0 1-5&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stage"><a class="markdownIt-Anchor" href="#stage"></a> stage</h4>
<p>stage指令包含在stages中，包含step、agent（可选）或其他特定包含于stage中的指令。实际上，Pipeline完成的所有实际工作都包含在一个或多个stage指令中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">至少一个</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">一个强制参数，一个标识stage名称的字符串。</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stages章节内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-9"><a class="markdownIt-Anchor" href="#样例-9"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tools"><a class="markdownIt-Anchor" href="#tools"></a> tools</h4>
<p>通过tools可自动安装工具，并放置环境变量到PATH。如果agent none，这将被忽略。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<p><strong>支持的Tools</strong></p>
<p>maven</p>
<p>jdk</p>
<p>gradle</p>
<h5 id="样例-10"><a class="markdownIt-Anchor" href="#样例-10"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">&#x27;apache-maven-3.0.1&#x27;</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>调用的tool必须被预置在Jenkins中，可通过<strong>Manage Jenkins</strong>→<strong>Global Tool Configuration配置。</strong></p>
<h4 id="when"><a class="markdownIt-Anchor" href="#when"></a> when</h4>
<p>when指令允许Pipeline根据给定的条件确定是否执行该阶段。when指令必须至少包含一个条件，如果when指令包含多个条件，则只有所有子条件返回true时才会执行stage，这与子条件嵌套在allOf相同（见下面的例子）。</p>
<p>更复杂的条件结构可使用嵌套条件：not，allOf或anyOf，嵌套条件可以嵌套到任意深度。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="内置条件"><a class="markdownIt-Anchor" href="#内置条件"></a> 内置条件</h5>
<p><strong>branch</strong></p>
<p>当正在构建的分支与给出的分支模式匹配时执行，例如：when { branch ‘master’ }。请注意，这仅适用于multibranch Pipeline。</p>
<p><strong>environment</strong></p>
<p>当指定的环境变量设置为指定值时执行，例如： when { environment name: ‘DEPLOY_TO’, value: ‘production’ }</p>
<p><strong>expression</strong></p>
<p>当指定的Groovy表达式求值为true时执行，例如： when { expression { return params.DEBUG_BUILD } }</p>
<p><strong>not</strong></p>
<p>当嵌套条件为false时执行。必须包含一个条件。例如：when { not { branch ‘master’ } }</p>
<p><strong>allOf</strong></p>
<p>当所有嵌套条件都为true时执行。必须至少包含一个条件。例如：when { allOf { branch ‘master’; environment name: ‘DEPLOY_TO’, value: ‘production’ } }</p>
<p><strong>anyOf</strong></p>
<p>当至少一个嵌套条件为真时执行。必须至少包含一个条件。例如：when { anyOf { branch ‘master’; branch ‘staging’ } }</p>
<h5 id="样例-11"><a class="markdownIt-Anchor" href="#样例-11"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;production&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; BRANCH_NAME ==~ <span class="regexp">/(production|staging)/</span> &#125;</span><br><span class="line">                anyOf &#123;</span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;production&#x27;</span></span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;staging&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-parallel并行"><a class="markdownIt-Anchor" href="#23-parallel并行"></a> 2.3 Parallel(并行)</h3>
<p>Declarative Pipeline的stages中可能包含多个嵌套的stage, 对相互不存在依赖的stage可以通过并行的方式执行，以提升pipeline的运行效率。</p>
<p>另外，通过在某个stage中设置“failFast true”，可实现当这个stage运行失败的时候，强迫所有parallel stages中止运行（详见下面的例子）。</p>
<h5 id="样例-12"><a class="markdownIt-Anchor" href="#样例-12"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Non-Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;This stage will be executed first.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            failFast <span class="literal">true</span></span><br><span class="line">            parallel &#123;</span><br><span class="line">                stage(<span class="string">&#x27;Branch A&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-a&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch A&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stage(<span class="string">&#x27;Branch B&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-b&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch B&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-steps步骤"><a class="markdownIt-Anchor" href="#24-steps步骤"></a> 2.4 Steps（步骤）</h3>
<p>Declarative Pipeline可使用Pipeline Steps手册中的所有可用步骤，以及以下仅在Declarative Pipeline中支持的步骤。</p>
<p>Pipeline Stepsreference：<a href="https://jenkins.io/doc/pipeline/steps/">https://jenkins.io/doc/pipeline/steps/</a></p>
<h4 id="script"><a class="markdownIt-Anchor" href="#script"></a> script</h4>
<p>script步骤中可以引用script Pipeline语句，并在Declarative Pipeline中执行。对于大多数用例，script在Declarative Pipeline中的步骤不是必须的，但它可以提供一个有用的加强。</p>
<h5 id="样例-13"><a class="markdownIt-Anchor" href="#样例-13"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">&#x27;chrome&#x27;</span>, <span class="string">&#x27;firefox&#x27;</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">&quot;Testing the $&#123;browsers[i]&#125; browser&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-scripted-pipeline"><a class="markdownIt-Anchor" href="#3-scripted-pipeline"></a> 3 Scripted Pipeline</h2>
<p>Groovy脚本不一定适合所有使用者，因此Jenkins创建了Declarative Pipeline，为编写Jenkins Pipeline提供了一种更简单、更有意义的语法。但是不可否认，由于脚本化的pipeline是基于groovy的一种DSL语言，所以与Declarative pipeline相比为Jenkins用户提供了更巨大的灵活性和可扩展性。</p>
<h3 id="31-流程控制"><a class="markdownIt-Anchor" href="#31-流程控制"></a> 3.1 流程控制</h3>
<p>Pipeline脚本同其它脚本语言一样，从上至下顺序执行，它的流程控制取决于Groovy表达式，如if/else条件语句，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (env.BRANCH_NAME == <span class="string">&#x27;master&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&#x27;I only execute on the master branch&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            echo <span class="string">&#x27;I execute elsewhere&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline脚本流程控制的另一种方式是Groovy的异常处理机制。当任何一个步骤因各种原因而出现异常时，都必须在Groovy中使用try/catch/finally语句块进行处理，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sh <span class="string">&#x27;exit 1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exc) &#123;</span><br><span class="line">            echo <span class="string">&#x27;Something failed, I should sound the klaxons!&#x27;</span></span><br><span class="line">            <span class="keyword">throw</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-steps"><a class="markdownIt-Anchor" href="#32-steps"></a> 3.2 Steps</h3>
<p>如本章开始所言，pipeline最核心和基本的部分就是“step”。从根本上来说，steps是作为Declarative pipeline和Scripted pipeline语法的最基本的语句块，来告诉jenkins应该执行什么操作。</p>
<p>Scripted pipeline不再专门将steps作为它的语法的一部分来介绍，但是在Pipeline Steps reference这篇文档中对pipeline及其插件涉及的steps做了很详细的介绍。如有需要可参考Jenkins官网对该部分的介绍。</p>
<h3 id="33-与普通groovy的区别"><a class="markdownIt-Anchor" href="#33-与普通groovy的区别"></a> 3.3 与普通Groovy的区别</h3>
<p>由于pipeline的一些个性化需求，比如在重新启动Jenkins后要求pipeline脚本仍然可以运行，那么pipeline脚本必须将相关数据做序列化，然而这一点 Groovy并不能完美的支持。</p>
<h3 id="34-declarative-pipeline和scripted-pipeline的比较"><a class="markdownIt-Anchor" href="#34-declarative-pipeline和scripted-pipeline的比较"></a> 3.4 Declarative Pipeline和Scripted Pipeline的比较</h3>
<p>共同点：</p>
<p>两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。</p>
<p>区别：</p>
<p>两者不同之处在于语法和灵活性。Declarative Pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。</p>
<h2 id="4-小结"><a class="markdownIt-Anchor" href="#4-小结"></a> 4 小结</h2>
<p>Pipeline语法是使用Jenkins Pipeline的基础，Jenkins提供了Declarative Pipeline和Scripted Pipeline两种语法结构，这两者在底层都是基于相同的Pipeline子系统，依照&quot;Pipeline as code&quot;的理念进行实现。</p>
<p>相对来说，Declarative Pipeline语法更简洁也更容易理解，而且可以与BlueOcean编辑器进行图形化操作结合，也是Jenkins社区鼓励使用的一种语法结构。</p>
<p>基于以上原因，<code>后面我们的交付流水线样例均采用 **Declarative语法** 结构进行编写。</code></p>
<h2 id="5-引用"><a class="markdownIt-Anchor" href="#5-引用"></a> 5 引用</h2>
<p><a href="https://jenkins.io/doc/book/pipeline/syntax/">Jenkins Pipeline 语法官方文档参考</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
</search>
