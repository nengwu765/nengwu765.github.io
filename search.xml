<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DevOps启蒙-开发测试管理系统</title>
    <url>/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>这个算是个回顾吧，自己再2019年进入X公司，发现开发测试流程耦合严重，没有独立的测试环境管理平台，所以参照自己的前东家（👉iflow系统）实现了一个<code>简单</code>的开发测试流程管理系统，当时的<code>思想还很稚嫩，观点粗浅</code>（算是自己DevOps启蒙篇吧），仅供参考哈。</p>
<span id="more"></span>
<p><strong>如果你对以下的内容感兴趣，可以一起探讨交流哦……</strong></p>
<ul>
<li>技术开发在项目移交测试后，既可以“放飞自我”、“自由飞翔”</li>
<li>测试妹子如何实现“私人定制”的测试环境，实现简单mock第三方Api</li>
<li>**终极：**如何让开发测试整个流程自动化</li>
</ul>
<h2 id="1-初来乍到遇到的问题"><a class="markdownIt-Anchor" href="#1-初来乍到遇到的问题"></a> 1、“初来乍到”，遇到的问题</h2>
<p>刚来到公司时，项目都是 <strong>小作坊管理方式</strong> 的，项目的流程规范不是很完善，有些项目让我接的有点“措手不及”吧。还有就是在开发移测后，自己需要过度介入整个测试过程，无法正常开始其他方面的工作：</p>
<p>总结以下吧：</p>
<ul>
<li>产品研发流程不完善</li>
<li>测试开发过度耦合，无法有效释放生成力</li>
</ul>
<p>结合我遇到的问题，我会和大家一起探讨解决问题。</p>
<h2 id="2-产品研发流程简介这不是本文重点"><a class="markdownIt-Anchor" href="#2-产品研发流程简介这不是本文重点"></a> 2、产品研发流程简介【这不是本文重点】</h2>
<p>其实在网上有很多资料，来说明一个互联网产品研发的流程了，基本大同小异。</p>
<p>我主要分以下几个部分简单说一下吧：</p>
<ul>
<li>需求阶段：产品需求调研【为什么要做；做了之后会带来什么好处；最终在数据上怎么体现】，明确需求优先级</li>
<li>方案阶段：产品原型文档，各负责人需求评审，<strong>一线开发&amp;测试</strong> 具体方案评审，排期</li>
<li>开发阶段：设计方案、编码、自测、提测</li>
<li>测试阶段：测试用例、线下测试、stage测试</li>
<li>上线：Beta环境，GA环境</li>
</ul>
<p>其中在产品的需求和方案阶段的流程完善可以通过人为 <strong>强制约束规范</strong> 得到有效解决</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B.gif" alt="img"></p>
<h2 id="3-开发测试中的问题"><a class="markdownIt-Anchor" href="#3-开发测试中的问题"></a> 3、开发&amp;测试中的问题</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TODO 大家都是码农，我就懒得说了，😄</span><br></pre></td></tr></table></figure>
<h2 id="4-开发测试流程体系"><a class="markdownIt-Anchor" href="#4-开发测试流程体系"></a> 4、开发测试流程体系</h2>
<h3 id="41-问题如何解决"><a class="markdownIt-Anchor" href="#41-问题如何解决"></a> 4.1、 问题如何解决</h3>
<p>问题真实存在，我们应该如何解决呢？怎样才能使我们的工作的更**<code>爽</code>**</p>
<p>我的思考：业务流程化 –&gt; 流程工具化 –&gt; 工具自动化(信息化)</p>
<h3 id="42-开发测试流程体系"><a class="markdownIt-Anchor" href="#42-开发测试流程体系"></a> 4.2、 开发测试流程体系</h3>
<p>其实很容易，在研发流程当中其实已经说明了开发测试的一个简单的流程体系，其主要就是三个阶段：</p>
<ul>
<li>Dev阶段：开发设计文档、创建分支、编码、自测、测试用例、提测</li>
<li>Test阶段：线下测试、Stage测试、代码审查、产品验收</li>
<li>Online阶段：Beta环境、GA环境</li>
</ul>
<p>流程化的过程如下：</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E6%B5%81%E7%A8%8B%E4%BD%93%E7%B3%BB.gif" alt="img"></p>
<h2 id="5-iflow开发测试流程管理系统"><a class="markdownIt-Anchor" href="#5-iflow开发测试流程管理系统"></a> 5、Iflow开发测试流程管理系统</h2>
<p>基于以上的问题和思考，以及以往的经验【这个占绝大部分】，我开发一套开发测试流程管理系统。所有的流程【除特出流程类型，如：<code>hotfix</code>】都是分步骤一步一步往下进行的，可以流程化管理。</p>
<p>Iflow系统特点：</p>
<ul>
<li>记录整个开发测试到上线的整个过程</li>
<li>主子流程明确，不会有流程交叉</li>
<li>严格流程化，当前流程之后的流程<strong>灰色</strong>，不可点击</li>
<li>流程化&amp;权限化，严格把控“出错”风险</li>
<li>测试环境统一化管理，测试可自由定制，mock第三方Api</li>
<li>后续可完善，做成CI系统</li>
</ul>
<h3 id="51-iflow-基本界面说明"><a class="markdownIt-Anchor" href="#51-iflow-基本界面说明"></a> 5.1、IFLOW — 基本界面说明</h3>
<ul>
<li>**主流程：**主阶段，创建Iflow、dev阶段、test阶段、online阶段</li>
<li>**子流程：**就是当前主极端对应的子阶段，如下图中 <strong>dev阶段</strong>，对应的开发文档阶段，创建分支……</li>
<li>**开发应用：**目前一个QS，可能需要关联开发多个应用，每个应用可以单独的流程，可以独立区分，便于不同的童鞋开发</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E6%9C%AC%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E.png" alt="img"></p>
<h3 id="52-iflow-创建iflow选择应用"><a class="markdownIt-Anchor" href="#52-iflow-创建iflow选择应用"></a> 5.2、IFLOW — 创建IFLOW（选择应用）</h3>
<p>目前根据QS-Id建立Iflow流程【注，目前未关联QS系统】，可以选择应用和不同的流程类型创建Iflow流程。</p>
<p>流程类型说明：</p>
<ul>
<li>正常：需要按常规走完流程</li>
<li>bug修复/Notesting/线上紧急bug：可以跳过特定的流程步骤</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="img"></p>
<h3 id="53-iflow-dev阶段"><a class="markdownIt-Anchor" href="#53-iflow-dev阶段"></a> 5.3、IFLOW — DEV阶段</h3>
<p>由对应<strong>开发走完整个流程</strong>，上传传文档审核，建立分支，自测，到最后提测。开发走完整个Dev阶段后移交测试。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/dev%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="54-iflow-test阶段"><a class="markdownIt-Anchor" href="#54-iflow-test阶段"></a> 5.4、IFLOW — TEST阶段</h3>
<p>由对应<strong>测试走完整个流程</strong></p>
<blockquote>
<p>首先测试可以在左侧菜单栏【iflow流程列表】，检索对应QS-ID，即可进入对应的流程测试，以及查看dev阶段的api文档和开发文档。</p>
</blockquote>
<blockquote>
<p>其次进入dev阶段完成相应阶段的测试，其中测试环境支持以下的功能：</p>
</blockquote>
<ul>
<li>**释放分支：**释放当前的测试环境绑定</li>
<li>**切换/更新分支：**将当前iflow流程对应的分支，切换至当前的测试环境</li>
<li>**更新dev配置文件：**基于目前环境存在的分支代码，同步copy更新dev配置文件，注意：更新后，原有的定制配置将被覆盖。</li>
<li>**配置文件修改：**更改/定制当前测试环境的配置文件</li>
<li>**模拟APi【mock第三方api数据】：**可以模拟第三方的api返回数据，设置超时，【使用前，注意绑定下对应模拟api的域名IP，不同的环境这个域名和IP不同】。</li>
</ul>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/test%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h3 id="55-iflow-online阶段"><a class="markdownIt-Anchor" href="#55-iflow-online阶段"></a> 5.5、IFLOW — ONLINE阶段</h3>
<p>即上线至beta环境和GA环境，显示但前版本列表，支持一键回退功能【目前只是一个空架子】。</p>
<p><img src="/2019/09/01/Iflow2345/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/online%E9%98%B6%E6%AE%B5.gif" alt="img"></p>
<h2 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6、总结</h2>
<p>整体来说IFLOW开发测试流程管理系统只是一个<strong>流程框架或者外壳</strong>，后续相关的功能的模块都可以进行集成，将其形成一套完善的流程管理系统（整体页面功能可能会比较简陋，当时花费一个多月的闲余时间写的😀）。</p>
<p><strong>可集成功能：</strong></p>
<ul>
<li>**文档系统：**api文档、Wiki知识库</li>
<li>**测试用例系统：**测试编写用例，开发可以审核过测试用例等</li>
<li>**自动化测试系统：**测试自动化测试脚本</li>
<li>**代码管理平台：**可以直接检测代码质量，给代码评分等，比如 <a href="http://bbs.2345.net/d/169-sonarqube/3"><strong>sonarQube，可点击此查看</strong></a></li>
<li>**打包构建工具：**比如jekins（PHP你懂的，木有构建哦😂）</li>
<li><strong>CI可持续集成</strong></li>
<li><strong>发布系统</strong></li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>Iflow</category>
      </categories>
      <tags>
        <tag>Iflow</tag>
      </tags>
  </entry>
  <entry>
    <title>OKR实践-初阶</title>
    <url>/2020/06/27/Mgmt-Practice/OKR%E5%AE%9E%E8%B7%B5-%E5%88%9D%E9%98%B6/</url>
    <content><![CDATA[<p>如OKR国内貌似字节“首推”，也一直践行着，至于大家要不要从原有的考核体系切换到比较<code>先进</code>的OKR呢？哈哈，没有答案！大伙儿根据自己的实际遇到的问题 + OKR的理念思想，进行考虑实践。这里只是简单介绍我践行的过程哈。</p>
<span id="more"></span>
<h2 id="1-接触okr"><a class="markdownIt-Anchor" href="#1-接触okr"></a> 1 、接触OKR</h2>
<h3 id="团队遇到的困难"><a class="markdownIt-Anchor" href="#团队遇到的困难"></a> 团队遇到的困难</h3>
<ul>
<li>任务管理</li>
<li>临时工作插入安排</li>
<li>重点工作目标推进</li>
</ul>
<h3 id="寻找方案"><a class="markdownIt-Anchor" href="#寻找方案"></a> 寻找方案</h3>
<p>偶然看到一个OKR的视频培训，之前有听说过（但是没有实践经验吧），当天看了视频直播，觉得值得一试。</p>
<p>《<a href="https://www.bilibili.com/video/BV1fk4y1r7oZ">如何应用OKR+敏捷实践驱动团队管理改进 丰之恺 中国DevOps社区第23期线上分享</a>》</p>
<h2 id="2-团队实践"><a class="markdownIt-Anchor" href="#2-团队实践"></a> 2、团队实践</h2>
<p><strong>团队宣导：理解目标，理解OKR</strong></p>
<ul>
<li>
<p>团队协商讨论，制定团队OKR，公开分享团队成员绩效计划</p>
</li>
<li>
<p>团队成员针对团队目标，制定个人OKR</p>
</li>
<li>
<p>确保目标达成，成员对OKR做敏捷计划拆解</p>
</li>
<li>
<p>每日站立晨会(10-20min)，对齐目标计划，重点讨论阻塞问题</p>
</li>
<li>
<p>每周回顾总结，对齐目标，有问题及时调整</p>
</li>
</ul>
<h3 id="21-使用工具"><a class="markdownIt-Anchor" href="#21-使用工具"></a> 2.1、使用工具</h3>
<p><strong>Confluence（共享、开放、透明） + JIRA（敏捷看板、计划跟进）</strong></p>
<h3 id="22-团队okr"><a class="markdownIt-Anchor" href="#22-团队okr"></a> 2.2、团队OKR</h3>
<p>针对组织目标（可以理解为领导下达的KPI），结合小伙伴的个人目标，团队共同制定出团队OKR。</p>
<p><img src="/2020/06/27/Mgmt-Practice/OKR%E5%AE%9E%E8%B7%B5-%E5%88%9D%E9%98%B6/%E5%9B%A2%E9%98%9FOKR-new.jpg" alt></p>
<h3 id="23-个人okr"><a class="markdownIt-Anchor" href="#23-个人okr"></a> 2.3、个人OKR</h3>
<p>小伙伴针对团队OKR进行拆解，为了可以确保目标达成，小伙伴还进行了详细的任务计划。</p>
<p><strong>每个O的Owner需主动推进该O和KR的达成，需要协助自主协调，对于该O富有绝对主导责任！</strong></p>
<p><img src="/2020/06/27/Mgmt-Practice/OKR%E5%AE%9E%E8%B7%B5-%E5%88%9D%E9%98%B6/%E4%B8%AA%E4%BA%BAOKR-new.jpg" alt></p>
<h2 id="3-实践参考"><a class="markdownIt-Anchor" href="#3-实践参考"></a> 3、实践参考</h2>
<ul>
<li><a href="https://blog.worktile.com/okr-okr-template-02-dev/?utm_source=segmentfault&amp;utm_medium=meiyang">技术研发类OKR制定</a></li>
<li><a href="https://www.atlassian.com/dam/jcr:a8b8a327-abd0-4c78-a493-9ff677efb6d0/OKRs-Blueprint.pdf">OKR模板.PDF - 本文参考使用的</a></li>
<li><a href="https://www.atlassian.com/software/confluence/templates/okrs">Confluence OKRS Template</a></li>
</ul>
]]></content>
      <categories>
        <category>管理实践</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(一)-工具选型</title>
    <url>/2021/05/27/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%80)-%E5%B7%A5%E5%85%B7%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>DevOps必不可少的一环就是代码扫描了，这里面包含了编码规范、代码缺陷、性能、漏洞的检测。目前也会有很多的开源静态代码扫描工具，如：SonarQube、Infer、PMD、FindBugs、CheckStyle。针对此做了简单的收集对比，各位可以根据自身的需求进行参考。</p>
<span id="more"></span>
<h2 id="工具选型调研"><a class="markdownIt-Anchor" href="#工具选型调研"></a> 工具选型调研</h2>
<h3 id="工具对比说明"><a class="markdownIt-Anchor" href="#工具对比说明"></a> 工具对比说明</h3>
<p>目前比较流行的开源的静态代码扫描工具：SonarQube、Infer、PMD、FindBugs、CheckStyle。因为后续会有流程定制化等需求，暂不考虑商业化的软件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">产品</th>
<th style="text-align:center">定位</th>
<th style="text-align:left">OpenApi</th>
<th style="text-align:left">Web项目友好</th>
<th style="text-align:left">支持代码质量检查</th>
<th style="text-align:left">支持语言</th>
<th style="text-align:left">可扩展性/插件支持</th>
<th style="text-align:left">是否侵入项目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SonarQube</td>
<td style="text-align:center">代码质量平台 <br>通过插件的<br>方式提供对各个<br>语言进行支持，<br>可以和 Checkstyle、PMD、Simian <br>等工具进行集成</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">常见语言都支持</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">Infer</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">否（移动端友好）</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">Android/java</td>
<td style="text-align:left">中</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">PMD</td>
<td style="text-align:center">代码分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">是</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">高</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">FindBugs</td>
<td style="text-align:center">字节码分析，侧重Bug检测</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">CheckStyle</td>
<td style="text-align:center">语法层面分析</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left"></td>
<td style="text-align:left">支持</td>
<td style="text-align:left">java</td>
<td style="text-align:left">低</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<h3 id="选型"><a class="markdownIt-Anchor" href="#选型"></a> 选型</h3>
<p>基于上述，<strong>选型SonarQube作为代码扫描工具</strong>，SonarQube 也是是一款目前比较流行的工具，国内很多互联网公司都选择用它来搭建静态检查的平台。</p>
<p>SonarQube介绍: <a href="https://www.sonarqube.org/">官网</a></p>
<h2 id="实施计划"><a class="markdownIt-Anchor" href="#实施计划"></a> 实施计划</h2>
<ul>
<li>SonarQube的部署使用调研</li>
<li>代码检测集成方案，（Jenkins、gitlab CI、代码检测时机等）</li>
<li>考虑代码质量平台管理（原生平台界面不友好、同时展示维度无法做到应用维度）</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> <strong>参考资料</strong></h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">资料</th>
<th style="text-align:left">概述</th>
<th style="text-align:left">参考价值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://testerhome.com/articles/24210">酷家乐质量效能 代码度量平台</a></td>
<td style="text-align:left">引入使用 SQALE 代码质量评估模型的 SonarQube 进行代码静态扫描，辅以 Cobra 的进行代码审计，Synk 进行三方包漏洞扫描，形成一套完整的代码度量工具链</td>
<td style="text-align:left"><strong>高</strong><br>整合平台页面参考</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://mp.weixin.qq.com/s/d9RzCFkYrW27m1_LkeA2rw">系列 | 58集团白盒代码审计系统建设实践1：技术选型</a></td>
<td style="text-align:left">对比了常见的的开源方案和商业方案，同时涉及介绍 SDL 相关检测知识</td>
<td style="text-align:left"><strong>高</strong><br>选型对比数据参考</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>JenkinsK8s集群部署AndroidSDK安装</title>
    <url>/2019/10/25/Mobile-CICD/JenkinsK8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2AndroidSDK%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>如过你的Jenkins是部署在K8s集群中的，那需要支持Android打包的情况。Android SDK安装与更新怎么做呢？<br>
<strong>本文将介绍在<code>K8s集群</code>中如何安装和更新 Android SDK</strong></p>
<span id="more"></span>
<h2 id="1-k8s集群中android-sdk安装与更新方案设计"><a class="markdownIt-Anchor" href="#1-k8s集群中android-sdk安装与更新方案设计"></a> 1. K8s集群中Android SDK安装与更新方案设计</h2>
<h3 id="11-android-sdk-tools镜像制作"><a class="markdownIt-Anchor" href="#11-android-sdk-tools镜像制作"></a> 1.1 Android SDK Tools镜像制作</h3>
<ul>
<li>使用Android SDK Tools</li>
</ul>
<p>Android在Jenkins中构建打包，只需要命令行工具即可（Command line tools only）。</p>
<p>只需安装Android SDK Tools，这是 Android SDK 的一个组件。它包含了 Android 的全套开发和调试工具，<a href="https://developer.android.google.cn/studio">在Android studios首页即可下载（位置：Command line tools only），点击进入</a>。</p>
<ul>
<li>使用<code>sdkmanager</code>进行工具管理</li>
</ul>
<p>使用 Android 的 <code>sdkmanager</code> 命令行工具进行查看、安装、更新和卸载 Android SDK 的软件包，<a href="https://developer.android.google.cn/studio/command-line/sdkmanager">sdkmanager工具介绍说明，点击进入</a></p>
<blockquote>
<p>注：<code>sdkmanager</code>工具在 Android SDK Tools 软件包（25.2.3 及更高版本）中提供，并位于 android_sdk/tools/bin/ 目录下，无需独立安装。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Android SDK Tools Dockerfile</span><br><span class="line">FROM harbor.demo.com/base/jre_centos:8u202_7.8</span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">ENV SDK_TOOLS_URL=&quot;https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip&quot; \</span><br><span class="line">    ANDROID_HOME=&quot;/opt/app/android-sdk&quot;</span><br><span class="line"></span><br><span class="line">RUN yum install -y zip unzip</span><br><span class="line">RUN mkdir -p &quot;$ANDROID_HOME&quot; .android \</span><br><span class="line">    &amp;&amp; cd &quot;$ANDROID_HOME&quot; \</span><br><span class="line">    &amp;&amp; curl -o sdk-tools.zip $SDK_TOOLS_URL \</span><br><span class="line">    &amp;&amp; unzip sdk-tools.zip \</span><br><span class="line">    &amp;&amp; rm sdk-tools.zip</span><br><span class="line">RUN yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses \</span><br><span class="line">    &amp;&amp; $ANDROID_HOME/tools/bin/sdkmanager --update</span><br><span class="line"></span><br><span class="line">#RUN $ANDROID_HOME/tools/bin/sdkmanager --install &quot;build-tools;29.0.1&quot; &quot;platforms;android-29&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="12-将android-sdk作为pvc挂载出来"><a class="markdownIt-Anchor" href="#12-将android-sdk作为pvc挂载出来"></a> 1.2 将Android sdk作为PVC挂载出来</h3>
<ul>
<li>
<p>k8s中申请50G的pvc挂载点</p>
</li>
<li>
<p>Android SDK Tools镜像挂载PVC</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装Android sdk工具</span><br><span class="line">sdkmanager --install XXX</span><br></pre></td></tr></table></figure>
<h3 id="13-android-sdk更新"><a class="markdownIt-Anchor" href="#13-android-sdk更新"></a> 1.3 Android SDK更新</h3>
<ul>
<li>使用cronjob重新发布一次即可</li>
</ul>
<p><strong><code>Cronjob更新稳定性不是很好，如果没有成功安装SDK工具，则可进入容器中，直接执行sdkmanager更新命令（cluster: cluster_pro 内网正式, namespace：jenkins，pod：androidsdk-xxxxx）</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// cronjob的部署示例：</span><br><span class="line">jobs:</span><br><span class="line">- name: androidsdk-job</span><br><span class="line">  # job运行环境集群，和 global.env 的值对应</span><br><span class="line">  runEnv:</span><br><span class="line">  - dev</span><br><span class="line">  - test</span><br><span class="line">  - pdt</span><br><span class="line">  image:</span><br><span class="line">     repository: harbor.demo.com/cicd/android-sdk-tools</span><br><span class="line">     tag: v0.0.1</span><br><span class="line">     pullPolicy: Always</span><br><span class="line">  command:</span><br><span class="line">  - &quot;/opt/app/android-sdk-v/tools/bin/sdkmanager&quot;</span><br><span class="line">  - &quot;--install&quot;</span><br><span class="line">  args:</span><br><span class="line">#### ./sdkmanager --list sdk包 ####</span><br><span class="line">#  - &quot;build-tools;19.1.0&quot;</span><br><span class="line">#  - &quot;build-tools;20.0.0&quot;</span><br><span class="line">#  - &quot;build-tools;21.1.2&quot;</span><br><span class="line">#  - &quot;build-tools;22.0.1&quot;</span><br><span class="line">#  - &quot;build-tools;23.0.1&quot;</span><br><span class="line">#  - &quot;build-tools;23.0.2&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="14-k8s集群中android-sdk安装与更新"><a class="markdownIt-Anchor" href="#14-k8s集群中android-sdk安装与更新"></a> 1.4 K8s集群中Android SDK安装与更新</h3>
<ul>
<li>使用Helm进行部署和更新，此处我们使用的是Helm方式部署的（有关Helm的部署，将后续分享……）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO chart部署仓库</span><br></pre></td></tr></table></figure>
<h2 id="2-jenkins-slave节点使用android-sdk工具"><a class="markdownIt-Anchor" href="#2-jenkins-slave节点使用android-sdk工具"></a> 2 Jenkins slave节点使用Android SDK工具</h2>
<ul>
<li>配置Jenkins slave节点</li>
</ul>
<p>添加一个环境变量和挂载卷</p>
<p><img src="/2019/10/25/Mobile-CICD/JenkinsK8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2AndroidSDK%E5%AE%89%E8%A3%85/jenkins%E9%85%8D%E7%BD%AE.png" alt="Jenkins配置"></p>
<ul>
<li>Jenkinsfile中使用</li>
</ul>
<p>直接使用对应Jenkins slave节点，执行gradle命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    // 全局执行代理</span><br><span class="line">    agent &#123;</span><br><span class="line">        kubernetes &#123;</span><br><span class="line">            cloud &#x27;kubernetes&#x27;</span><br><span class="line">            label &#x27;label-gradle&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	stages &#123;</span><br><span class="line">        stage (&quot;gradle构建&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &quot;./gradlew clean &quot; +</span><br><span class="line">                        &quot;channelRelease --stacktrace &quot; +</span><br><span class="line">                        &quot;-PBUILD_NUMBER=$&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>移动CICD</category>
      </categories>
      <tags>
        <tag>移动CICD</tag>
        <tag>Jenkins</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins部署-K8s OR 物理机</title>
    <url>/2021/06/10/Jenkins/Jenkins%E9%83%A8%E7%BD%B2-K8sOR%E7%89%A9%E7%90%86%E6%9C%BA/</url>
    <content><![CDATA[<p>如果你开始使用Jenkins作为你的CI工具，刚好也在使用K8s集群做CD，那你一定很纠结我的Jenkins到底用什么方式进行部署管理呢？<br>
这里我将我们遇到的实际经验分享给各位参考，希望能给到你一些帮助吧，😄</p>
<span id="more"></span>
<h2 id="1-结论"><a class="markdownIt-Anchor" href="#1-结论"></a> 1、结论</h2>
<p>不拖沓，直接上结论：</p>
<p><strong>轻易不要上K8s</strong>，启动速度和Slave镜像管理以及构建缓存等会比较<code>耗精力</code>；在CICD起步，日构建在500次左右，特别是含Android的gradle构建时，建议直接上物理机，绝对<code>真香</code>。</p>
<blockquote>
<p>选择适合的，并不是技术领先的，当然能Hold住的大佬，请随意哈😁</p>
</blockquote>
<hr>
<p>备注说明下目前我遇到的构建量级吧，相对大厂是小儿科了点，勿喷哈。</p>
<ul>
<li>Web应用构建，约日均构建在400-500次/日</li>
<li>移动端构建（Android为主），约日均构建在30-50次/日，偶尔会有批量的渠道打包量比较大（渠道量1K+）</li>
</ul>
<h2 id="2-k8s集群里的jenkins"><a class="markdownIt-Anchor" href="#2-k8s集群里的jenkins"></a> 2、K8s集群里的Jenkins</h2>
<h3 id="21-选择背景"><a class="markdownIt-Anchor" href="#21-选择背景"></a> 2.1、选择背景</h3>
<p>公司开始做中台了，其中包括建设CICD系统，基本是从 O 起步吧，当初直接选型了：java spring微服务 + K8s作为接下来的技术发展方向。作为<code>打辅助</code>的持续交付系统也就那个时候定型的，选型CI工具为Jenkins（当然还有很多的周边的工具链选型），部署原则：<strong>Everything in docker</strong></p>
<h3 id="22-遇到问题"><a class="markdownIt-Anchor" href="#22-遇到问题"></a> 2.2、遇到问题</h3>
<ul>
<li>K8s集群稳定性是第一大考验</li>
<li>动态的Slave启动慢，修改长时间存活，莫名会出现心跳终端，SalvePod假死</li>
<li>各Slave节点构建依赖的缓存共享设置，尤其是移动端的Gradle的缓存（谁用谁知道！参考：<a href="https://blog.dreamtobe.cn/lls_ci/">流利说客户端持续交付工程实践</a>……）</li>
<li>Slave多了后占用的资源无法想象，最后不得不给Jenkins独立的Node，打上标签区分</li>
<li>还有就是构建过程，一个字儿：<strong>超级慢</strong>，很大原因是K8s集群的Ceph文件系统</li>
<li>Slave镜像维护成本也颇高，尤其是需要版本升级的时候</li>
<li>…</li>
</ul>
<h2 id="3-物理机里的jenkins"><a class="markdownIt-Anchor" href="#3-物理机里的jenkins"></a> 3、物理机里的Jenkins</h2>
<h3 id="31-选择背景"><a class="markdownIt-Anchor" href="#31-选择背景"></a> 3.1、选择背景</h3>
<p>我们重新建设了DevOps平台（定位：一站式研发协同平台），对于原有的功能迁移后，发现对于很多<code>核心、根本</code>问题，治标不治本。新平台也迫切需要出成绩，最终开出了 <code>历史的倒车</code>，我们回到了物理机Jenkins。</p>
<h3 id="32-效果"><a class="markdownIt-Anchor" href="#32-效果"></a> 3.2、效果</h3>
<p>一个字：<strong>快</strong>，平均提速达到30%+（其中移动端提速了甚至到了50%），且稳定性更高</p>
<h3 id="33-成本核算"><a class="markdownIt-Anchor" href="#33-成本核算"></a> 3.3、成本核算</h3>
<p>迁移到物理是不是成本很高啊，那可是物理机啊，然并卵……</p>
<table>
<thead>
<tr>
<th style="text-align:center">迁移前</th>
<th>迁移后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">K8s独立Node：64c+128G（1），32c+32G（1）</td>
<td>32c+32G（5）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(三)-Sonar+Jenkins+Gitlab集成</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%B8%89)-Sonar+Jenkins+Gitlab/</url>
    <content><![CDATA[<p>目前我们使用CI工具主要是Jenkins，所以此相互选择了jenkins进行集成。根据实际情况，也可选择GitlabCI等工具。</p>
<p>实施代码检测，Gitlab 代码变更（Push/Merge），触发Jenkins Job执行SonarScanner扫描代码，SonarServer通过Gitlab插件，将代码扫描完的结果回写至Gitlab，GitLab即可查看到对应Sonar检测的结果代码注释，方便开发人员代码排查</p>
<span id="more"></span>
<h2 id="实现目的"><a class="markdownIt-Anchor" href="#实现目的"></a> 实现目的</h2>
<ul>
<li>1、研发过程，Jenkins在构建过程，加入SonarQube的代码质量门，检测本次构建增量代码质量</li>
<li>2、定期的全量代码质量扫描，在每周定期对公司所有代码进行全量扫描，产出代码质量报告</li>
</ul>
<h2 id="集成插件配置"><a class="markdownIt-Anchor" href="#集成插件配置"></a> 集成插件配置</h2>
<h3 id="1-jenkins插件配置"><a class="markdownIt-Anchor" href="#1-jenkins插件配置"></a> 1、Jenkins插件&amp;配置</h3>
<p><strong>插件：</strong></p>
<ul>
<li>SonarQubeScannerForJenkins</li>
</ul>
<p><strong>配置：</strong></p>
<ul>
<li>SonarServer配置：Manage Jenkins – &gt; Configure System – &gt; SonarQube servers<br>
需要SonarQube基于高权限账号生成的 授权token （SonarQube：Administration – &gt; Security – &gt; Users）</li>
<li>SonarScanner配置：Manage Jenkins – &gt; Global Tool Configuration – &gt; SonarQube Scanner<br>
备注：<strong>这里安装多个SonarQube Scanner，为多项目并行代码扫描做准备</strong></li>
</ul>
<h3 id="2-sonarqube配置"><a class="markdownIt-Anchor" href="#2-sonarqube配置"></a> 2、SonarQube配置</h3>
<p><strong>插件：</strong></p>
<p>实现gitlab打通，<strong>同时实现gitlab auth授权登陆</strong>。</p>
<ul>
<li>sonar-gitlab-plugin：<a href="https://github.com/javamachr/sonar-gitlab-plugin">https://github.com/javamachr/sonar-gitlab-plugin</a></li>
<li>**sonar-auth-gitlab-plugin：**<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin</a></li>
</ul>
<p>**Sonar Serverbase Url设置：**Administration &gt; Configuration &gt; General&gt; Server base URL</p>
<p><strong>Webhook配置：（实操，不配置，JEnkins在获取质量门结果时会无限等待）</strong></p>
<p>Administration &gt; Configuration &gt; Webhooks. The URL should point to your Jenkins server： <code>http://&#123;JENKINS_HOST&#125;/sonarqube-webhook/</code></p>
<p>具体说明：参考Jenkins官方文档说明（<a href="https://www.jenkins.io/doc/pipeline/steps/sonar/#waitforqualitygate-wait-for-sonarqube-analysis-to-be-completed-and-return-quality-gate-status">Configure a webhook in your SonarQube server pointing</a> … ）</p>
<p><strong>Gitlab授权登陆：</strong></p>
<p>Administration &gt; Configuration &gt; GitLab &gt; Authentication ：设置对应的 Application ID + Secret</p>
<p>(设置参数说明，参考对应的插件说明：<a href="https://github.com/gabrie-allaigre/sonar-auth-gitlab-plugin">sonar-auth-gitlab-plugin</a>)</p>
<p><strong>Gitlab Reporting配置：</strong></p>
<ul>
<li>
<p>作用：可以将检测结果报告已comment的形式回写至Gitlab的Commit中（注：目前版本不支持inline comment in commit，现在只有global comment，具体看附属问题记录说明）</p>
</li>
<li>
<p>配置：Administration &gt; Configuration &gt; GitLab &gt; Reporting</p>
</li>
<li>
<p>参数：扫描时需要配置参数：sonar.gitlab.project_id</p>
</li>
</ul>
<p>说明：这个可以根据实际需求配置说明，此处可根据需求配置将检测的结果是否以comment回写。此处暂时不配置。</p>
<h3 id="3-gitlab配置"><a class="markdownIt-Anchor" href="#3-gitlab配置"></a> 3、Gitlab配置</h3>
<p><strong>授权登陆设置：</strong><br>
Admin Settings -&gt; Application：设置对应的回调：https://<your sonar domain>/oauth2/callback/gitlab (备注：sonar的domain不可为IP+Port形式，经测试http目前也是支持)</your></p>
<h2 id="问题记录"><a class="markdownIt-Anchor" href="#问题记录"></a> 问题记录</h2>
<ul>
<li>SonarCloud + GitHub + Pull Request Analysis = No Inline Comments：<a href="https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2">https://community.sonarsource.com/t/sonarcloud-github-pull-request-analysis-no-inline-comments/7371/2</a><br>
目前最后支持的版本：sonarqube v7.6</li>
<li>新扫描项目（新sonar project key） No branches currently exist in this project. Please scan the main branch without passing any branch parameters<br>
注：新项目必须先扫描 master（稳定）分支，才可以进行其他分支的扫描</li>
<li>不建议写入sonar.language扫描参数： <a href="https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993">https://community.sonarsource.com/t/what-is-the-alternative-to-the-sonar-language-property-in-the-current-version-of-sonarqube/3993</a></li>
<li>SonarQube插件矩阵（可查看相关产检兼容情况）：<a href="https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/">https://docs.sonarqube.org/latest/instance-administration/plugin-version-matrix/</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://docs.sonarqube.org/latest/">SonarQube官方文档</a></li>
<li><a href="https://gitbook.curiouser.top/origin/SonarQube%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B.html">SonarQube静态代码扫描分析简介</a></li>
</ul>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins共享库使用-初阶</title>
    <url>/2021/06/08/Jenkins/Jenkins%E5%85%B1%E4%BA%AB%E5%BA%93%E4%BD%BF%E7%94%A8-%E5%88%9D%E9%98%B6/</url>
    <content><![CDATA[<p>在我们实际写Jenkin pipelines脚本中，可能会出现``java.lang.RuntimeException: Method code too large!<code>，这个时候你就要抽象出一些公共的函数类库，</code>避免项目方重复冗余的脚本代码书写`，在此处我也把我经常使用的一些共享函数库（<strong><a href="https://github.com/nengwu765/jenkins-share-library">jenkins-share-library</a></strong>）分享出来，欢迎交流指正哈！</p>
<span id="more"></span>
<h2 id="1-如何使用jenkins共享库"><a class="markdownIt-Anchor" href="#1-如何使用jenkins共享库"></a> 1. 如何使用Jenkins共享库</h2>
<ul>
<li>在Jenkinsfile的脚本文件第一行引入以下代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library &#x27;jenkins-shared-libraries&#x27;</span><br><span class="line"></span><br><span class="line">pipeline &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>调用示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage (&quot;demo&quot;) &#123;</span><br><span class="line">	steps &#123;</span><br><span class="line">		script &#123;</span><br><span class="line">			// 调用：共享方法名+入参</span><br><span class="line">			demoFunction(params1, params2, ...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-支持的共享库方法"><a class="markdownIt-Anchor" href="#2-支持的共享库方法"></a> 2. 支持的共享库方法</h2>
<h3 id="21-git仓库拉取-gitcodefetch"><a class="markdownIt-Anchor" href="#21-git仓库拉取-gitcodefetch"></a> 2.1 Git仓库拉取 - gitCodeFetch()</h3>
<p>支持基于分支/标签 和 Submodule子仓库拉取以及基于MR拉取分支，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/gitCodeFetch.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Git仓库版本拉取 -- 支持基于分支/标签 和 Submodule子仓库拉取以及基于MR拉取分支</span><br><span class="line"> *</span><br><span class="line"> * @param fetchMode Git代码拉取方式：branch-基于分支; tag-基于标签</span><br><span class="line"> * @param gitBranchOrTag Git仓库分支 或 标签</span><br><span class="line"> * @param gitRepository  Git仓库地址</span><br><span class="line"> * @param gitCredentialsId  Git拉取凭证ID 【若存在Submodule子仓库，则该凭证需要有子仓库拉取权限】</span><br><span class="line"> * @param gitEvent  git拉取事件,基于分支或Tag拉取,则置空; MergeRequest则为:&quot;MR&quot;</span><br><span class="line"> * @param targetBranch 若gitEvent为&quot;MR&quot;,此处为MR目标分支</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">void call(String fetchMode,String gitBranchOrTag, String gitRepository, String gitCredentialsId, String gitEvent = &#x27;&#x27;, String targetBranch = &#x27;&#x27;) </span><br></pre></td></tr></table></figure>
<h3 id="22-md5值校验-md5check"><a class="markdownIt-Anchor" href="#22-md5值校验-md5check"></a> 2.2 MD5值校验 - md5Check()</h3>
<p>文件MD5值check，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/md5Check.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件MD5值check</span><br><span class="line"> *</span><br><span class="line"> * @param filePath 文件路径</span><br><span class="line"> * @param md5 文件md5值</span><br><span class="line"> * @param forceCheck 是强制检查，是-必检，否-md5值非空则进行检查</span><br><span class="line"> */</span><br><span class="line">void md5Check(String filePath, String md5, boolean forceCheck = true)</span><br><span class="line"></span><br><span class="line">注：forceCheck=true时，校验不通过则报错，流水线终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23-sha1值校验-sha1check"><a class="markdownIt-Anchor" href="#23-sha1值校验-sha1check"></a> 2.3 SHA1值校验 - sha1Check()</h3>
<p>文件SHA1值check，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/sha1Check.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件SHA1值check</span><br><span class="line"> *</span><br><span class="line"> * @param filePath 文件路径</span><br><span class="line"> * @param sha1 文件md5值</span><br><span class="line"> * @param forceCheck 是强制检查，是-必检，否-md5值非空则进行检查</span><br><span class="line"> */</span><br><span class="line">void sha1Check(String filePath, String sha1, boolean forceCheck = true)</span><br><span class="line"></span><br><span class="line">注：forceCheck=true时，校验不通过则报错，流水线终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="24-ftp上传-ftpupload"><a class="markdownIt-Anchor" href="#24-ftp上传-ftpupload"></a> 2.4 FTP上传 - ftpUpload()</h3>
<p>FTP文件上传  – // 参数参考说明：<a href="https://jenkins.io/doc/pipeline/steps/publish-over-ftp">https://jenkins.io/doc/pipeline/steps/publish-over-ftp</a></p>
<p><a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/ftpUpload.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * FTP文件上传  -- // 参数参考说明：https://jenkins.io/doc/pipeline/steps/publish-over-ftp</span><br><span class="line"> * @param configName  在Jenkins全局设置的FTP Server名称</span><br><span class="line"> * @param sourceFiles  上传源文件，支持正则匹配，如[递归目录层级使用&#x27;**&#x27;]：&#x27;**/*.apk,public/**/*&#x27;</span><br><span class="line"> * @param remoteDir  上传子目录路径，注此路径会追加到全局设置的FTP Server的Remote Directory之后</span><br><span class="line"> * @param excludes  排除上传文件，支持正则匹配，如[递归目录层级使用&#x27;**&#x27;]： &#x27;**/*.log,**/*.tmp,.git/&#x27;</span><br><span class="line"> * @param removePrefix  去除上传文件的路径前缀，避免ftp服务器中生成无用的目录路径,注：所有上传文件必须都有该前缀，否则报错</span><br><span class="line"> */</span><br><span class="line">void ftpUpload(String configName, String sourceFiles, String remoteDir = &#x27;&#x27;, String excludes = &#x27;&#x27;, String removePrefix = &#x27;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="25-rsync-module远程同步-rsyncmodule"><a class="markdownIt-Anchor" href="#25-rsync-module远程同步-rsyncmodule"></a> 2.5 Rsync Module远程同步 - rsyncModule()</h3>
<p>rsync 使用Module远程同步，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/rsyncWithModule.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  rsync 使用Module远程同步</span><br><span class="line"> *</span><br><span class="line"> * @param ip rsync服务器IP</span><br><span class="line"> * @param port rsync服务器监听端口</span><br><span class="line"> * @param path rsync本地同步绝对路径</span><br><span class="line"> * @param module rsync同步模块</span><br><span class="line"> * @param user  rsync同步用户，指定传输文件为指定用户</span><br><span class="line"> * @param customParams 定制rsync参数，不允许出现&quot;delete&quot;关键字，如：--exclude=PATTERN --include=PATTERN --exclude-from=FILE --include-from=FILE</span><br><span class="line"> * @param bwlimit</span><br><span class="line"> */</span><br><span class="line">void rsyncModule(String ip, int port, String path, String module, String user = &#x27;&#x27;, String customParams = &#x27;&#x27;, int bwlimit = 8192)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="26-制品上传nexus-uploadartifactstonexus"><a class="markdownIt-Anchor" href="#26-制品上传nexus-uploadartifactstonexus"></a> 2.6 制品上传Nexus - uploadArtifactsToNexus()</h3>
<p>如果你是以Nexus作为制品库的话，这个可以作为参考，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/uploadArtifactsToNexus.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 上传制品至Nexus仓库</span><br><span class="line"> *</span><br><span class="line"> * @param nexusRepository Nexus上传仓库</span><br><span class="line"> * @param dir 检索目录</span><br><span class="line"> * @param fileMatchRegex 文件正则匹配规则， 支持文件类型、文件前缀、文件全名，</span><br><span class="line"> *        如文件：prefix_file.test,</span><br><span class="line"> *        匹配规则：</span><br><span class="line"> *              文件类型： fileMatchRegex = &quot;.test&quot;</span><br><span class="line"> *              文件前缀： fileMatchRegex = &quot;prefix_&quot;</span><br><span class="line"> *              文件全名： fileMatchRegex = &quot;prefix_file.test&quot;</span><br><span class="line"> * @param uploadSubPath 制品上传路经</span><br><span class="line"> * @param isRecursion 是否递归检索子目录,默认：否【注：同名文件会被覆盖】</span><br><span class="line"> * @param artifacts 制品存储数据，Map结构，默认：空Map</span><br><span class="line"> * @return Map 返回上传制品数据</span><br><span class="line"> *         eg: [</span><br><span class="line"> *              &#x27;file1&#x27;:[</span><br><span class="line"> *                  &#x27;url&#x27;:&#x27;https://nexus.demo.com/.../file1&#x27;  // 文件在nexus中的上传路径【即下载路径】</span><br><span class="line"> *                  &#x27;md5&#x27;:&#x27;xxxx&#x27; // 文件md5值</span><br><span class="line"> *                  &#x27;sha1&#x27;:&#x27;xxxx&#x27;   // 文件sha1值</span><br><span class="line"> *               ],</span><br><span class="line"> *         ]</span><br><span class="line"> */</span><br><span class="line">def uploadArtifactsToNexus(String nexusRepository, String dir, String fileMatchRegex, String uploadPath, boolean isRecursion = false, Map artifacts = [:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Android制品上传Nexus - uploadAndroidArtifacts()</li>
</ul>
<p><strong><code>针对Android制品上传，做了一层外围封装，防止不同业务上传仓库紊乱</code></strong>，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/uploadAndroidArtifacts.groovy">源码参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 上传制品至Nexus仓库</span><br><span class="line"> *</span><br><span class="line"> * @param dir 检索目录</span><br><span class="line"> * @param fileMatchRegex 文件正则匹配规则， 支持文件类型、文件前缀、文件全名，</span><br><span class="line"> *        如文件：prefix_file.test,</span><br><span class="line"> *        匹配规则：</span><br><span class="line"> *              文件类型： fileMatchRegex = &quot;.test&quot;</span><br><span class="line"> *              文件前缀： fileMatchRegex = &quot;prefix_&quot;</span><br><span class="line"> *              文件全名： fileMatchRegex = &quot;prefix_file.test&quot;</span><br><span class="line"> * @param uploadSubPath 制品上传路经</span><br><span class="line"> * @param isRecursion 是否递归检索子目录,默认：否【注：同名文件会被覆盖】</span><br><span class="line"> * @param artifacts 制品存储数据，Map结构，默认：空Map</span><br><span class="line"> * @return Map 返回上传制品数据</span><br><span class="line"> *         eg: [</span><br><span class="line"> *              &#x27;file1&#x27;:[</span><br><span class="line"> *                  &#x27;url&#x27;:&#x27;https://nexus.demo.com/.../file1&#x27;  // 文件在nexus中的上传路径【即下载路径】</span><br><span class="line"> *                  &#x27;md5&#x27;:&#x27;xxxx&#x27; // 文件md5值</span><br><span class="line"> *                  &#x27;sha1&#x27;:&#x27;xxxx&#x27;   // 文件sha1值</span><br><span class="line"> *               ],</span><br><span class="line"> *         ]</span><br><span class="line"> */</span><br><span class="line">def uploadAndroidArtifacts(String dir, String fileMatchRegex, String uploadPath, boolean isRecursion = false, Map artifacts = [:])</span><br></pre></td></tr></table></figure>
<h3 id="27-流水线结果回调-callbackaction"><a class="markdownIt-Anchor" href="#27-流水线结果回调-callbackaction"></a> 2.7 流水线结果回调 - callBackAction()</h3>
<p>Jenkins pipeline结果回调通知（这个其实有个Plugin支持，Job Notification，但是我觉得不够灵活），这边我自定义了一个通用回调，可以防止在任何位置，<a href="https://github.com/nengwu765/jenkins-share-library/blob/master/vars/callBackAction.groovy">源码参考</a></p>
<ul>
<li>入参说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 流水线执行结果回调操作</span><br><span class="line"> *</span><br><span class="line"> * @param callBackUrlsJson 回调Url地址Json数据</span><br><span class="line"> * @param artifacts 制品存储数据</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">void callBackAction(String callBackUrlsJson, Map artifacts = [:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">	agent any</span><br><span class="line"></span><br><span class="line">	stages &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">	post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            // 回调Api通知对接JOB执行结果</span><br><span class="line">            script &#123;</span><br><span class="line">                if (!binding.variables.containsKey(&quot;ARTIFACTS&quot;)) &#123;</span><br><span class="line">                    ARTIFACTS = [:]</span><br><span class="line">                &#125;</span><br><span class="line">                callBackAction(params.CALLBACK_URLS_JSON, ARTIFACTS)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            echo &quot;I will be executed while failed or succeed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-引用"><a class="markdownIt-Anchor" href="#5-引用"></a> 5 引用</h2>
<p><a href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/">官方参考，Extending with Shared Libraries</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(二)-SonarQube安装</title>
    <url>/2021/05/31/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E4%BA%8C)-SonarQube%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>SonarQube的安装会给予版本有些差异，建议根据你选择的版本结合官方的文档进行安装，中间遇到问题再自行Google一下啦。本文主要是讲解一下版本的安装：SonarQube：7.9 LTS +PostgreSQL 10</p>
<span id="more"></span>
<h2 id="版本选择"><a class="markdownIt-Anchor" href="#版本选择"></a> 版本选择</h2>
<p>不同的版本对应的插件选择和数据库支持不同，同时需要考虑版本的稳定性。考虑稳定性，避免出现问题无法跟进处理解决，生产环境不考虑最新版本。</p>
<p>SonarQube：7.9 LTS</p>
<p>SonarQube v7.9 的前置依赖说明（<a href="https://docs.sonarqube.org/7.9/requirements/requirements/%EF%BC%89">https://docs.sonarqube.org/7.9/requirements/requirements/）</a></p>
<ul>
<li>数据库：PostgreSQL 10</li>
<li>Java JDK：OpenJDK 11</li>
</ul>
<h2 id="安装说明"><a class="markdownIt-Anchor" href="#安装说明"></a> 安装说明</h2>
<h3 id="1-openjdk-11安装"><a class="markdownIt-Anchor" href="#1-openjdk-11安装"></a> 1、OpenJDK 11安装</h3>
<p>官方安装引导：<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a></p>
<p>安装包（Linux/x64）：（<a href="https://download.java.net/openjdk/jdk11/ri/openjdk-11+28_linux-x64_bin.tar.gz">官方下载</a> ）</p>
<p><strong>解压缩</strong></p>
<p>&gt; tar -zxvf openjdk-11+28_linux-x64_bin.tar.gz</p>
<p><strong>配置环境变量</strong></p>
<p>&gt; 末尾增加如下内容(根据自己jdk目录修改)：<br>
&gt; export JAVA_HOME=/usr/local/jdk-11<br>
&gt; export CLASSPATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/lib:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>CLASSPATH<br>
&gt; export PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>A</mi><mi>V</mi><msub><mi>A</mi><mi>H</mi></msub><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>i</mi><mi>n</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">JAVA_HOME/bin:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>PATH</p>
<p><strong>验证</strong></p>
<p>&gt; java -version</p>
<h3 id="2-postgresql-10安装"><a class="markdownIt-Anchor" href="#2-postgresql-10安装"></a> 2、PostgreSQL 10安装</h3>
<p>官方的安装引导：<a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></p>
<ul>
<li>Select version：10</li>
<li>Select platform：CentOS 7</li>
<li>Select architecture: x86_64</li>
</ul>
<p>执行安装脚本及初始化启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装repo源</span></span><br><span class="line">sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装服务端</span></span><br><span class="line">sudo yum install -y postgresql10-server</span><br><span class="line"> </span><br><span class="line"><span class="comment"># PGsql进行初始化</span></span><br><span class="line">sudo /usr/pgsql-10/bin/postgresql-10-setup initdb</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加入开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启动PGsql</span></span><br><span class="line">stl start postgresql-10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status postgresql-10.service</span><br></pre></td></tr></table></figure>
<p>初始化SonarQube使用的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到postgres用户</span></span><br><span class="line">su - postgres</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连接到数据库</span></span><br><span class="line">psql</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">CREATE DATABASE sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER sonarqube WITH PASSWORD <span class="string">&#x27;xxxxx&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE sonarqube TO sonarqube;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建授权（必须）</span></span><br><span class="line">ALTER DATABASE sonarqube owner to sonarqube;</span><br></pre></td></tr></table></figure>
<p>修改pg数据的pg_hba.conf（<a href="http://www.postgres.cn/docs/10/auth-pg-hba-conf.html"><code>pg_hba.conf</code>文件说明</a>）将认证 ident 改为 md5，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># &quot;local&quot; is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all             all                                     peer</span><br><span class="line"><span class="comment"># IPv4 local connections:</span></span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line"><span class="comment"># IPv6 local connections:</span></span><br><span class="line">host    all             all             ::1/128                 md5</span><br><span class="line"><span class="comment"># Allow replication connections from localhost, by a user with the</span></span><br><span class="line"><span class="comment"># replication privilege.</span></span><br><span class="line"><span class="comment">#local   replication     postgres                                peer</span></span><br><span class="line"><span class="comment">#host    replication     postgres        127.0.0.1/32            ident</span></span><br><span class="line"><span class="comment">#host    replication     postgres        ::1/128                 ident</span></span><br><span class="line"><span class="comment">#host    replication     sonar           127.0.0.1/32            ident</span></span><br></pre></td></tr></table></figure>
<h3 id="3-sonarqube-79安装"><a class="markdownIt-Anchor" href="#3-sonarqube-79安装"></a> 3、SonarQube 7.9安装</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/setup/install-server/">https://docs.sonarqube.org/7.9/setup/install-server/</a></p>
<p>安装包：（<a href="https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.9.6.zip">官方下载</a>）</p>
<p><strong>创建sonar用户</strong></p>
<p>&gt; sudo useradd sonar</p>
<p>&gt; passwd sonar (密码：xxxx)</p>
<p>linux平台文件数限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置系统最大文件数</span></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">sysctl -w fs.file-max=65536</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置sonar用户再打文件数 文件：/etc/security/limits.d/99-sonarqube.conf (or /etc/security/limits.conf as you wish)，注：终端需退出重登生效或source后生效？</span></span><br><span class="line">sonar -   nofile   65536</span><br><span class="line">sonar -   nproc    4096</span><br></pre></td></tr></table></figure>
<p><strong>安装配置</strong></p>
<ul>
<li>数据库链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.jdbc.username=sonarqube</span><br><span class="line">&gt; sonar.jdbc.password=mypassword</span><br><span class="line">&gt; sonar.jdbc.url=jdbc:postgresql://localhost/sonarqube</span><br></pre></td></tr></table></figure>
<ul>
<li>ES存储</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sonar.path.data=/opt/data/sonarqube/data</span><br><span class="line">&gt; sonar.path.temp=/opt/data/sonarqube/temp</span><br></pre></td></tr></table></figure>
<ul>
<li>Web Server配置</li>
</ul>
<p>自己设定启动端口配置即可</p>
<p><strong>脚本启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="variable">$&#123;sonar_home&#125;</span>/bin/linux-x86-64/sonar.sh start</span><br></pre></td></tr></table></figure>
<p>服务器部署，注意加入到开机启动项中,，此处我是加入 rc.local 文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sonarqube server</span></span><br><span class="line">su - sonar -c <span class="string">&quot;/opt/app/sonarqube/sonarqube-7.9.6/bin/linux-x86-64/sonar.sh start&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-sonarqube-scanner"><a class="markdownIt-Anchor" href="#4-sonarqube-scanner"></a> 4、SonarQube Scanner</h3>
<p>官方的安装引导：<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/</a></p>
<p>安装包：（<a href="https://docs.sonarqube.org/7.9/analysis/scan/sonarscanner/">官方下载</a>）</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置SonarQube Server，位置：$install_directory/conf/sonar-scanner.properties</span></span><br><span class="line"><span class="comment">#----- Default SonarQube server</span></span><br><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将$install_directory/bin，加入到环境变量PATH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 sonar-scanner -h ，做验证</span></span><br></pre></td></tr></table></figure>
<p>**每个扫描项目的根目录加入：**sonar-project.properties</p>
<p>sonar-project.properties示例： <a href="https://github.com/SonarSource/sonar-scanning-examples">browsed</a> or <a href="https://github.com/SonarSource/sonar-scanning-examples/archive/master.zip">downloaded</a></p>
<h3 id="5-sonarqube-plugin"><a class="markdownIt-Anchor" href="#5-sonarqube-plugin"></a> 5、SonarQube Plugin</h3>
<ul>
<li>社区版支持多分支检测： <a href="https://github.com/mc1arke/sonarqube-community-branch-plugin">sonarqube-community-branch-plugin</a>（1.3.2老版本，安装<a href="https://github.com/mc1arke/sonarqube-community-branch-plugin/commit/a6b6db3f30e1ebba7183825542d1f5363b66a831#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5">区别现说明</a>：Copy the plugin JAR file to the <code>extensions/plugins/</code> <strong>and</strong> the <code>lib/common/</code> directories of your SonarQube instance and restart SonarQube）</li>
<li>汉化包（不建议，总觉得怪怪的）：直接在应用市场检索按照对应的版本即可（jar插件下载：<a href="https://github.com/xuhuisheng/sonar-l10n-zh">sonar-l10n-zh</a>）</li>
</ul>
<h3 id="6-相关配置"><a class="markdownIt-Anchor" href="#6-相关配置"></a> 6、相关配置</h3>
<ul>
<li><strong>解决增量代码小于20行，QG不生效情况：</strong></li>
</ul>
<p>&gt; 配置：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<h2 id="问题记录"><a class="markdownIt-Anchor" href="#问题记录"></a> 问题记录</h2>
<p><strong>1、Some Quality Gate conditions on New Code were ignored because of the small number of New Lines</strong></p>
<p>但分支模式增量代码扫描，少于20行时，代码坏味道无法检测到，可以参考：<a href="https://jira.sonarsource.com/browse/SONAR-9352">SONAR-9352</a> 或 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a></p>
<p>解决：解决方案说明参考 <a href="https://groups.google.com/g/sonarqube/c/qxQLr7OAioA/m/Dk9J7Ji8BgAJ?pli=1">论坛讨论</a>，</p>
<p>步骤：sonarqube → quality gates → create/copy a new QG , set :Lines to Cover on New Code to 0</p>
<p><strong>2、the main branch has no lines of code</strong></p>
<p>扫描php，遇到的错误，主要原因是唯一的php的文件在解析阶段就出现错误，无法正常解析，也就没有扫描文件，更没有扫描结果了。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ol>
<li><a href="https://bbs.huaweicloud.com/blogs/159762">SonarQube安装及踩坑体验</a></li>
<li><a href="https://blog.csdn.net/CN_TangZheng/article/details/109244806">调研sonarqube版本区别</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1732805">从零开始针对 .NET 应用的 DevOps 运营实践 - Jenkins &amp; SonarQube 安装配置</a></li>
</ol>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(一)-概述及框架</title>
    <url>/2019/09/25/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%80)-%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>我们基于禅道打造了持续交付系统，整合了多个开源系统（包括禅道zentao、jenkins、gitlab、nexus、harbor、ldap、mysql等等），并进行大量的二次开发，将多个系统功能（项目管理、集成管理、代码仓库管理、编译私服，镜像仓库管理、用户认证等）、多个开发环境（开发环境、测试环境、预发布环境、灰度环境、生产环境等），多种发布流程（代码扫描、版本集成、版本发布等）进行统一整合，提供一套高度集成和高度自动化的项目管理+版本集成发布系统。</p>
<span id="more"></span>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1、概述</h2>
<p>因为公司大部门在使用禅道进行项目管理、缺陷管理等，所以我们希望基于此对于禅道做二开扩展，支持到CICD，最终将禅道打造成一个DevOps平台。</p>
<p>选择禅道主要原因：</p>
<ul>
<li>有使用历史，符合大多数业务项目的操作习惯</li>
<li>敏捷管理，基于Scrum的角色且相关流程和功能完善</li>
<li>社区版开源，可以基于源码进行修改</li>
</ul>
<p><strong>拓展后禅道能力</strong></p>
<ul>
<li><a href="https://www.zentao.net/book/zentaopmshelp/49.html">使用禅道来进行项目任务管理</a></li>
<li><a href="https://www.zentao.net/book/zentaopmshelp/64.html">只使用禅道来做bug管理</a></li>
<li><a href="https://www.zentao.net/book/zentaopmshelp/77.html">只使用禅道来进行产品管理</a></li>
<li><a href="https://www.zentao.net/book/zentaopmshelp/91.html">个人使用禅道来做事务跟踪管理</a></li>
<li>仅使用版本集成流程（扩展功能）</li>
<li>仅使用上线流程审批功能（扩展功能）</li>
<li>仅使用客户端渠道管理功能（扩展功能）</li>
</ul>
<h2 id="2-持续交付系统框架"><a class="markdownIt-Anchor" href="#2-持续交付系统框架"></a> 2、持续交付系统框架</h2>
<p>这个比较简单吧，其实有关这种分层的DevOps架构，应该都是大同小异，仅供参考哈😉</p>
<p><img src="/2019/09/25/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%80)-%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A1%86%E6%9E%B6/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-new.png" alt="img"></p>
<h2 id="3-持续交付流程"><a class="markdownIt-Anchor" href="#3-持续交付流程"></a> 3、持续交付流程</h2>
<p>主要是基于Helm进行K8s的容器部署，整个交付流程如下：</p>
<ul>
<li>使用Zentao作为项目管理工具：管理基本需求、迭代、缺陷等</li>
<li>Zentao也作为用户CICD系统平台，用户再禅道上做集成、构建、部署等操作</li>
<li>CICD的后端集成工具：Jenkins</li>
<li>部署至K8s集群中，部署主要的使用是Helm进行部署管理（注：当时使用的是Helm2）</li>
</ul>
<p>注：我们自己编写了Helm的Template模板工程，基本涵盖了很多的使用场景，这个后续我也会跟进分享给大家，尽情期待……</p>
<p><img src="/2019/09/25/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%80)-%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A1%86%E6%9E%B6/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B-new.png" alt="img"></p>
<h2 id="4-工具链选型"><a class="markdownIt-Anchor" href="#4-工具链选型"></a> 4、工具链选型</h2>
<p>其实DevOps工具链产品有很多，大家可以根据自己的实际情况选择，我们基于Zentao打造的持续交付平台选择的是如下工具链。因为当初我们还木有打通持续测试这一环节，所以这个相对有些简陋了，但是还算清晰！</p>
<p><img src="/2019/09/25/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%80)-%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A1%86%E6%9E%B6/%E5%B7%A5%E5%85%B7%E9%93%BE%E9%80%89%E5%9E%8B-new.png" alt="img"></p>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>代码扫描(四)-DevOps平台集成Sonar方案</title>
    <url>/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>SonarQube需要融合到DevOps平台，使其成为CICD的一个环节中来，发挥其更大的价值。我们需要考虑到如何与DevOps平台的集成，并且可以最小限度的对于业务代码的侵入性，这边文档将我的方案做个各详细阐述和大家一起分享。</p>
<span id="more"></span>
<h2 id="1-扫描流程"><a class="markdownIt-Anchor" href="#1-扫描流程"></a> 1、扫描流程</h2>
<p>整个代码扫描涉及工具、系统如下：</p>
<ul>
<li>Gitlab</li>
<li>Jenkins</li>
<li>SonarQube</li>
<li>DevOps平台（代码扫描开发应用）</li>
</ul>
<p><strong>执行流程如下：</strong></p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/Sonar%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B-new.jpg" alt="Jenkins配置"></p>
<h2 id="2-详细说明"><a class="markdownIt-Anchor" href="#2-详细说明"></a> 2、详细说明</h2>
<h3 id="21-devops平台代码"><a class="markdownIt-Anchor" href="#21-devops平台代码"></a> 2.1、DevOps平台（代码）</h3>
<p>代码扫描以一个开放应用的形式接入研发中台，有一个基本Widget页面，展示代码扫描结果概览</p>
<p>所有的检测结果可以基于研发中台进行处理</p>
<ul>
<li>流程中断</li>
<li>消息告警</li>
</ul>
<p><strong>SonarQube开放应用界面</strong></p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/Sonar%E5%BC%80%E6%94%BE%E5%BA%94%E7%94%A8-new.jpg" alt="Jenkins配置"></p>
<h3 id="22-jenkins扫描job"><a class="markdownIt-Anchor" href="#22-jenkins扫描job"></a> 2.2、Jenkins扫描Job</h3>
<p>所有触发通过研发中台触发，所以Jenkins只配置一个通用扫描Job即可，使用Pipeline Job编写。</p>
<p><strong>说明：所以参数拼接可以研发中台传递给 Jenkins，所以业务代码可以不用 sonar-project.properties文件，减少业务代码的侵入性</strong></p>
<h4 id="jenkins-job入参"><a class="markdownIt-Anchor" href="#jenkins-job入参"></a> Jenkins Job入参</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;commonParams&quot;: &#123;</span><br><span class="line">		&quot;appCode&quot;: &quot;php-demo&quot;,     // 应用编号唯一，对应：sonar.projectkey</span><br><span class="line">		&quot;appLanguage&quot;: &quot;php&quot;,   // 应用语言，针对不同语言设置默认的扫描命令及参数，如：php、go、java、gradle</span><br><span class="line">		&quot;gitRepository&quot;: &quot;git@gitlab.demo.com:demo/php-demo.git&quot;,  // 代码仓库地址</span><br><span class="line">		&quot;gitProjectId&quot;: &quot;&quot;,   // GitLab仓库PojectId，对应：sonar.gitlab.project_id，Comment on Commit需要</span><br><span class="line">		&quot;gitBranch&quot;: &quot;test&quot;,  // 扫描代码分支，对应：sonar.branch.name</span><br><span class="line">		&quot;gitCommit&quot;: &quot;&quot;,  // 代码提交Commit Hash值，对应：sonar.gitlab.commit_sha</span><br><span class="line">		&quot;gitRefName&quot;: &quot;master&quot;  // 扫描参考基准分支或Commit，对应：sonar.gitlab.ref_name</span><br><span class="line">        &quot;gitEvent&quot;: &quot;Merge Request Hook&quot;,   // git触发事件类型，Push Hook、Merge Request Hook、Flow Build、Fast Build等</span><br><span class="line">		&quot;mrKey&quot;: &quot;1&quot;,   // MR Key，对应：sonar.pullrequest.key</span><br><span class="line">		&quot;mrSourceBranch&quot;: &quot;test-mr&quot;,   // MR来源分支，对应：sonar.pullrequest.branch</span><br><span class="line">		&quot;mrTargetBranch&quot;: &quot;master&quot;  // MR目标分支，对应：sonar.pullrequest.base</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;extendParams&quot;: &#123;  // 预留扩展参数，如自定义扫描参数等</span><br><span class="line">		&quot;customAnalysisParams&quot;: &#123;        // 以下会默认覆盖原有既定扫描参数</span><br><span class="line">			&quot;sonar.sourceEncoding&quot;: &quot;GBK&quot;,</span><br><span class="line">			&quot;sonar.projectBaseDir&quot;: &quot;/src/code&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jenkins-pipeline示例"><a class="markdownIt-Anchor" href="#jenkins-pipeline示例"></a> Jenkins pipeline示例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (&quot;参数解析&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    echo params.BUILD_PARAMS_JSON</span><br><span class="line">                    if (params.BUILD_PARAMS_JSON != null &amp;&amp; params.BUILD_PARAMS_JSON != &#x27;&#x27;) &#123;</span><br><span class="line">                        buildParams = readJSON text: params.BUILD_PARAMS_JSON</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        error &quot;BUILD_PARAMS_JSON is required params&quot;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 通用参数与定制参数赋值</span><br><span class="line">                    COMMON_PARAMS = buildParams[&#x27;commonParams&#x27;]</span><br><span class="line">                    EXTEND_PARAMS = buildParams[&#x27;extendParams&#x27;]</span><br><span class="line"></span><br><span class="line">                    // 入参json数据校验,通用参数必须包含 appCode + gitRepository</span><br><span class="line">                    if (COMMON_PARAMS[&#x27;appCode&#x27;].isEmpty() || COMMON_PARAMS[&#x27;gitRepository&#x27;].isEmpty() ) &#123;</span><br><span class="line">                        error &quot;buildParams[&#x27;commonParams&#x27;] is error, must have appCode and gitRepository&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // gitBranch不存在则默认为master</span><br><span class="line">                    COMMON_PARAMS[&#x27;gitBranch&#x27;].isEmpty() &amp;&amp; (COMMON_PARAMS[&#x27;gitBranch&#x27;] = &quot;master&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage (&quot;代码拉取&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // 不同的应用对应不同的工作空间,避免工作空间相互影响覆盖</span><br><span class="line">                dir (&quot;$&#123;COMMON_PARAMS[&#x27;appCode&#x27;]&#125;&quot;) &#123;</span><br><span class="line">                    // 拉取git仓库代码， 默认基于分支拉取</span><br><span class="line">                    script &#123;</span><br><span class="line">                        if (COMMON_PARAMS[&#x27;gitEvent&#x27;] == &quot;Merge Request Hook&quot; || !COMMON_PARAMS[&#x27;mrKey&#x27;].isEmpty()) &#123;</span><br><span class="line">                            // SCM: MR必须使用此进行拉取代码,否则Sonar Scan无法识别此次SCM是基于MR</span><br><span class="line">                            gitCodeFetch(&quot;branch&quot;, COMMON_PARAMS[&#x27;mrSourceBranch&#x27;], COMMON_PARAMS[&#x27;gitRepository&#x27;], params.GITLAB_DEPLOY_CRED, &quot;MR&quot;, COMMON_PARAMS[&#x27;mrTargetBranch&#x27;])</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            gitCodeFetch(&quot;branch&quot;, COMMON_PARAMS[&#x27;gitBranch&#x27;], COMMON_PARAMS[&#x27;gitRepository&#x27;], params.GITLAB_DEPLOY_CRED)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 扫描参数此处组织,则业务代码无需sonar-project.properties文件,不侵入业务代码</span><br><span class="line">        stage (&quot;扫描参数组织&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    ANALYSIS_PARAMS = [:]</span><br><span class="line">                    // =================  通用扫描参数 ==========================</span><br><span class="line">                    // 通用扫描参数,其中个别参数存在值才进行赋值,否则空值可能会出现扫描异常情况</span><br><span class="line">                    ANALYSIS_PARAMS[&#x27;sonar.projectKey&#x27;] = COMMON_PARAMS[&#x27;appCode&#x27;]</span><br><span class="line">                    ANALYSIS_PARAMS[&#x27;sonar.projectName&#x27;] = COMMON_PARAMS[&#x27;appCode&#x27;]</span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                    // =================  各语言的约定扫描参数 ======================</span><br><span class="line">                    // 各语言的约定扫描参数,如:sonar.exclusions,sonar.sourceEncoding,默认扫描报告文件位置: .scannerwork/report-task.txt</span><br><span class="line">                    REPORT_FILE_PATH = &quot;.scannerwork/report-task.txt&quot;</span><br><span class="line">                    if (COMMON_PARAMS[&#x27;appLanguage&#x27;] == &quot;php&quot;) &#123;</span><br><span class="line">                        ANALYSIS_PARAMS[&#x27;sonar.exclusions&#x27;] = &quot;vendor/**&quot;</span><br><span class="line">                    &#125; else if (COMMON_PARAMS[&#x27;appLanguage&#x27;] == &quot;go&quot;) &#123;</span><br><span class="line">                        ANALYSIS_PARAMS[&#x27;sonar.exclusions&#x27;] = &quot;vendor/**&quot;</span><br><span class="line">                    &#125; else if (COMMON_PARAMS[&#x27;appLanguage&#x27;] == &quot;java&quot;) &#123;</span><br><span class="line">                        // 以下mvn sonar:sonar 会默认设置,对于multi-module的仓库同样适用</span><br><span class="line">                        //ANALYSIS_PARAMS[&#x27;sonar.sources&#x27;] = &quot;src&quot;</span><br><span class="line">                        //ANALYSIS_PARAMS[&#x27;sonar.java.binaries&#x27;] = &quot;target/classes&quot;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // TODO</span><br><span class="line">                        echo &quot;TODO&quot;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // =================  定制化扫描参数 ======================</span><br><span class="line">                    // 定制化扫描参数(研发中台页面配置), 放置最后,可覆盖之前约定扫描参数</span><br><span class="line">                    if (!EXTEND_PARAMS[&#x27;customAnalysisParams&#x27;].isEmpty()) &#123;</span><br><span class="line">                        EXTEND_PARAMS[&#x27;customAnalysisParams&#x27;].each &#123; key,value -&gt;</span><br><span class="line">                            ANALYSIS_PARAMS[&quot;$&#123;key&#125;&quot;] = value</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage (&quot;前置扫描操作&quot;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                dir(&quot;$&#123;COMMON_PARAMS[&#x27;appCode&#x27;]&#125;&quot;) &#123;</span><br><span class="line">                    script &#123;</span><br><span class="line">                        if (COMMON_PARAMS[&#x27;appLanguage&#x27;] == &quot;java&quot;) &#123;</span><br><span class="line">                            // java 语言需前置编译, 下载统一的setting.xml文件</span><br><span class="line">                            sh &quot;wget -O settings.xml http://.../settings-sonar.xml&quot;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            echo &quot;Do Nothing&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage (&quot;代码扫描&quot;) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                GIT_COMMIT = &quot;&quot;  // 此环境变量置空, 否则影响MR检测时的Sonar回写Gitlab,注:取值为jenkins pipeline 仓库的Hash值</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                dir(&quot;$&#123;COMMON_PARAMS[&#x27;appCode&#x27;]&#125;&quot;) &#123;</span><br><span class="line">                    script &#123;</span><br><span class="line">                        // 扫描参数拼接</span><br><span class="line">                        println(JsonOutput.toJson(ANALYSIS_PARAMS))</span><br><span class="line">                        def analysisParams = &#x27;&#x27;</span><br><span class="line">                        ANALYSIS_PARAMS.each &#123; key,value -&gt;</span><br><span class="line">                            analysisParams += &quot;-D&quot; + key + &quot;=&quot; + value + &quot; &quot;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        def scannerHome = tool &#x27;SonarScanner&#x27;</span><br><span class="line">                        withSonarQubeEnv(&quot;SonarServer&quot;) &#123;</span><br><span class="line">                            if (COMMON_PARAMS[&#x27;appLanguage&#x27;] == &quot;java&quot;) &#123;</span><br><span class="line">                                // 适应multi-module的仓库, 将 sonar:sonar 作为独立的一步执行</span><br><span class="line">                                //sh &quot;mvn -s settings.xml clean install -Dmaven.test.skip=true&quot;</span><br><span class="line">                                sh &quot;mvn -s settings.xml clean install&quot;</span><br><span class="line">                                sh &quot;mvn -s settings.xml sonar:sonar $&#123;analysisParams&#125;&quot;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                sh &quot;$&#123;scannerHome&#125;/bin/sonar-scanner $&#123;analysisParams&#125;&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 扫描质量门结果</span><br><span class="line">                        timeout(time: 1, unit: &#x27;HOURS&#x27;) &#123;</span><br><span class="line">                             // 返回格式Map,示例: &#123;&quot;status&quot;:&quot;OK / ERROR&quot;&#125;, 返回放置在 ARTIFACTS[&#x27;qualityGate&#x27;]</span><br><span class="line">                            ARTIFACTS[&#x27;qualityGate&#x27;] = waitForQualityGate()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.3、SonarQube</p>
<p>登陆和Gitlab进行打通，实现联动登陆（Gitlab完成登陆了，则SonarQube即自动登陆）</p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/Sonar%E7%99%BB%E9%99%86.png" alt="Jenkins配置"></p>
<p>2.4、Gitlab</p>
<p>实现扫描结果 Comment on Commit ，<a href="https://gitlab.2345.cn/qiannw/wg-php-demo/commit/95e08b1428c0d7b1bae90f1d4b8facc136baae97">示例查看</a>（注：会同时给对应的代码提交人发送一封邮件通知 [Gitlab的Commit自带的配置]）</p>
<p>注：根据实际需求进行，需要传入 <code>sonar.gitlab.project_id 参数</code></p>
<p><strong>基于MR的Comment</strong></p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/MR-Sonar%E8%B4%A8%E9%87%8F%E9%98%88.png" alt="Jenkins配置"></p>
<h2 id="问题记录"><a class="markdownIt-Anchor" href="#问题记录"></a> 问题记录</h2>
<h3 id="1-sonarqube-扫描项目的权限问题"><a class="markdownIt-Anchor" href="#1-sonarqube-扫描项目的权限问题"></a> 1、SonarQube 扫描项目的权限问题</h3>
<p>默认设置，登陆用户均可以查看，这个会造成源代码泄露风险</p>
<p><strong>处理方式：</strong></p>
<ul>
<li>Default visibility of new projects: <strong>Private</strong> 位置：Administration &gt; Projects &gt; Management 右上角</li>
<li>修改全局的权限设置模板，位置：Administration &gt; Security &gt; Default template &gt; Edit，设置如下：</li>
<li><strong>新项目，通过Api接口设置对应的用户，有对应的权限：</strong></li>
</ul>
<p><strong>全局权限+新用户权限</strong></p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/%E5%85%A8%E5%B1%80%E6%9D%83%E9%99%90.png" alt="Jenkins配置"></p>
<p><img src="/2021/06/03/SonarQube/%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F(%E5%9B%9B)-DevOps%E5%B9%B3%E5%8F%B0%E9%9B%86%E6%88%90Sonar%E6%96%B9%E6%A1%88/%E4%BA%BA%E5%91%98%E6%9D%83%E9%99%90.png" alt="Jenkins配置"></p>
<h3 id="2-基于mr扫描状态结果回写gitlab"><a class="markdownIt-Anchor" href="#2-基于mr扫描状态结果回写gitlab"></a> 2、基于MR扫描状态结果回写Gitlab</h3>
<ul>
<li>
<p>**坑1：目前使用7.9.x 对应的 branch plugin-1.3.2需要加入此参数(否则报错),后续针对8.x版本则不再需要<br>
**参数：sonar.pullrequest.gitlab.repositorySlug的值对应MR的iid值</p>
</li>
<li>
<p>**坑2：使用Jenkins Pipeline SCM模式，默认的变量GIT_COMMIT变量会影响到sonar扫描结果回写<br>
**此环境变量置空, 否则影响MR检测时的Sonar回写Gitlab,注:取值为jenkins pipeline 仓库的Hash值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage (&quot;代码扫描&quot;) &#123;</span><br><span class="line">    environment &#123;</span><br><span class="line">         GIT_COMMIT = &quot;&quot;  // 此环境变量置空, 否则影响MR检测时的Sonar回写Gitlab,注:取值为jenkins pipeline 仓库的Hash值</span><br><span class="line">       &#125;</span><br><span class="line">    steps &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>SonarQube</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>代码扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(七)-失败总结</title>
    <url>/2020/03/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%83)-%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>哈哈，想不到吧，虽然经过小伙伴的很长时间的努力，我们最终落地的效果是不理想。最终项目被”砍“掉了。不过很值得和大家分享下，感觉这篇应该是这个系列最<code>值钱</code>的一篇啦，不容错过！</p>
<span id="more"></span>
<h2 id="1-持续交付最终结果"><a class="markdownIt-Anchor" href="#1-持续交付最终结果"></a> 1、持续交付最终结果</h2>
<p>在完成试点后，整体落地推进整体结果不是很好，总结两句话</p>
<ul>
<li>Web端使用体验很操作</li>
<li>移动端整体尚可</li>
</ul>
<p>最终由于**”领导层“**的决定，禅道<code>寿终正寝</code>了 😢😢😢</p>
<h2 id="2-失败原因"><a class="markdownIt-Anchor" href="#2-失败原因"></a> 2、失败原因</h2>
<p>其实在禅道命运的变更和我司上层调整是一个重合的时间节点，当初我一度很”郁闷“，想不通这个是一个正确的事儿，K8s也是前沿趋势，我门打造的可是我司第一个统一产研研发大平台……</p>
<p>但是随着时间推移和经历更多的DevOps的实践，发现禅道的”死亡“一定程度上是必然的，我会逐步给到各位解释哈。</p>
<h3 id="21-空中楼阁核心原因"><a class="markdownIt-Anchor" href="#21-空中楼阁核心原因"></a> 2.1、空中楼阁（核心原因）</h3>
<p>我们打造的持续交付系统可能先对于公司当时的现状来说太”高、大、尚“了，因为技术层面整体 <strong>底层建设不牢</strong></p>
<ul>
<li>软件版本和架构未标准化  –  容器化改造能定制化到你怀疑人生</li>
<li>运维自动化程度低（基本处于脚本时代吧） – 配置改造、域名标准</li>
<li>无标准化测试环境 – 大家各自的测试环境基本各成体系</li>
<li>自身建设的K8s集群先对稳定性不足</li>
<li>大部分小伙伴其实都没有准备好</li>
</ul>
<p>基建其实是一个很庞大的工程，不是一个持续交付系统所能撑起来的，我基于个人的理解把它们理解成一套房子，而持续交付属于Roof一环，如果Foundation和House都没有建设好的化，直接盖”屋顶“，这将是一个很艰难的过程。</p>
<p><img src="/2020/03/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%83)-%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/%E7%A9%BA%E4%B8%AD%E6%A5%BC%E9%98%81-new.jpg" alt></p>
<h3 id="22-技术选型"><a class="markdownIt-Anchor" href="#22-技术选型"></a> 2.2、技术选型</h3>
<p><strong><code>并不是最新、先进就是合适的</code></strong>，我觉得当时起步选择了Helm并不是一个明知的决定，学习成本太高，专业技术方向人员还Ok，当时需要推向多有业务小伙伴使用，这个成本可想而知，入门成本同时带来的问题就是维护起来也是一个浩大的工程。</p>
<h3 id="23-自身易用性"><a class="markdownIt-Anchor" href="#23-自身易用性"></a> 2.3、自身易用性</h3>
<p>我们基于禅道自身Scrum框架，做了很多流程、角色限制，最终的结果感觉就是<strong>作茧自缚</strong>。说实话这个就是机械的贯彻了标准的软件生命周期流程（也可以理解为瀑布式），然而他并不”敏捷“。</p>
<p>流程过度的自由，会引发不可预知的问题，但流程机械化的强制管控，会引起生产效率的降低以及<code>怨声载道</code>。在流程和效率中间找到一个平衡，或者说DevOps落地的不同阶段我们可以逐步规范，这估计也是 <strong>敏捷思想</strong> 想引导的，可惜的是：<strong>当时的我们并不知道这些（认知局限）</strong></p>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(三)-多环境同域名设计</title>
    <url>/2019/10/25/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%89)-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>在实际需求中，我们遇到了这样一个需求：在<code>研发环境</code>和<code>测试环境</code>使用相同的域名，期望根据访问者<code>IP</code>将访问请求转发到对应环境，并能对<code>IP</code>与<code>环境</code>的绑定关系进行管理。基于此我们调研最后实现这个需求。方案核心点：OpenResty方案: Nginx+lua + redis 实现根据访问者<code>IP</code>将访问请求转发到对应环境，并能对<code>IP</code>与<code>环境</code>的绑定关系进行管理，redis用于管理用户Client IP和环境的绑定关系。</p>
<span id="more"></span>
<h2 id="1-需求调研"><a class="markdownIt-Anchor" href="#1-需求调研"></a> 1 需求调研</h2>
<p>在<code>研发环境</code>和<code>测试环境</code>使用相同的域名，期望根据访问者<code>IP</code>将访问请求转发到对应环境，并能对<code>IP</code>与<code>环境</code>的绑定关系进行管理。</p>
<h2 id="2-方案概述"><a class="markdownIt-Anchor" href="#2-方案概述"></a> 2 方案概述</h2>
<ol>
<li>使用<code>OpenResty</code>(集成了 Nginx 和 Lua )对用户请求进行转发</li>
<li>使用<code>Redis</code>来存储用户 IP 与环境的绑定关系数据</li>
<li>使用禅道操作<code>Redis</code>来管理用户 IP 与环境的绑定关系</li>
</ol>
<h2 id="3-部署实践"><a class="markdownIt-Anchor" href="#3-部署实践"></a> 3 部署实践</h2>
<h3 id="31-openresty-部署"><a class="markdownIt-Anchor" href="#31-openresty-部署"></a> 3.1 OpenResty 部署</h3>
<p><a href="https://openresty.org/en/">OpenResty官方介绍</a></p>
<h4 id="311-openresty-安装"><a class="markdownIt-Anchor" href="#311-openresty-安装"></a> 3.1.1 OpenResty 安装</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line">sudo yum install -y openresty</span><br><span class="line">sudo yum install -y openresty-resty</span><br></pre></td></tr></table></figure>
<h4 id="312-openresty-配置"><a class="markdownIt-Anchor" href="#312-openresty-配置"></a> 3.1.2 OpenResty 配置</h4>
<h5 id="3121-nginx-配置"><a class="markdownIt-Anchor" href="#3121-nginx-配置"></a> 3.1.2.1 nginx 配置</h5>
<p>路径：/usr/local/openresty/nginx/conf/nginx.conf</p>
<ul>
<li>配置文件路径根据 openresty 安装目录变化</li>
<li>配置文件中<code>lua_package_path</code>字段值也要根据 openresty 安装目录变化</li>
</ul>
<p>配置样例：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>                 root root;</span><br><span class="line"><span class="attribute">worker_processes</span>     auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span>  auto;</span><br><span class="line"><span class="attribute">error_log</span>            logs/error.log <span class="literal">info</span>;</span><br><span class="line"><span class="attribute">pid</span>                  logs/nginx.pid;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65000</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span>                 <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">accept_mutex</span>        <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">20480</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lua相关配置</span></span><br><span class="line">    <span class="attribute">lua_package_path</span>                   <span class="string">&#x27;/usr/local/openresty/lualib/?.lua;/usr/local/openresty/nginx/conf/?.lua&#x27;</span>;</span><br><span class="line">    <span class="attribute">lua_shared_dict</span>                    xq_req_limit_cache <span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">lua_need_request_body</span>              <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3122-代理域名配置"><a class="markdownIt-Anchor" href="#3122-代理域名配置"></a> 3.1.2.2 代理域名配置</h5>
<p>路径：/usr/local/openresty/nginx/conf/conf.d/domain.conf</p>
<ul>
<li>配置文件路径根据 openresty 安装目录变化</li>
<li>配置文件中<code>access_log、error_log、rewrite_by_lua_file</code>字段值也要根据 openresty 安装目录变化</li>
</ul>
<p>配置样例：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> domain.demo.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /usr/local/openresty/nginx/logs/domain.demo.com.access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /usr/local/openresty/nginx/logs/domain.demo.com.<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">set</span> $target_domain <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="attribute">set</span> $target_host <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">rewrite_by_lua_file</span> /usr/local/openresty/nginx/conf/proxy.lua;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $target_domain;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://$target_host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3123-lua脚本"><a class="markdownIt-Anchor" href="#3123-lua脚本"></a> 3.1.2.3 Lua脚本</h5>
<p>路径：/usr/local/openresty/nginx/conf/proxy.lua</p>
<ul>
<li>配置文件路径根据 openresty 安装目录变化</li>
<li>配置文件中<code>file_err</code>字段值也要根据 openresty 安装目录变化</li>
</ul>
<p>配置样例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 日志文件</span></span><br><span class="line"><span class="keyword">local</span> file_err = <span class="string">&quot;/usr/local/openresty/nginx/logs/&quot;</span>..<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%d&quot;</span>, <span class="built_in">os</span>.<span class="built_in">time</span>())..<span class="string">&quot;-proxy-lua.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- json模块</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写日志函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(type, msg)</span></span></span><br><span class="line">    <span class="built_in">type</span> = <span class="built_in">type</span> <span class="keyword">or</span> <span class="string">&quot;INFO&quot;</span></span><br><span class="line">    files = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(file_err, <span class="string">&quot;a+&quot;</span>))</span><br><span class="line">    files:<span class="built_in">write</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%d %X&quot;</span>, <span class="built_in">os</span>.<span class="built_in">time</span>())..<span class="string">&quot; &quot;</span>..<span class="built_in">type</span>..<span class="string">&quot; &quot;</span>..cjson.encode(msg)..<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    files:<span class="built_in">close</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取客户端IP</span></span><br><span class="line"><span class="keyword">local</span> client_ip = ngx.req.get_headers()[<span class="string">&quot;X-Real-IP&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> client_ip == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    client_ip = ngx.req.get_headers()[<span class="string">&quot;x_forwarded_for&quot;</span>]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> client_ip == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    client_ip = ngx.var.remote_addr</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- redis模块</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span> </span><br><span class="line"><span class="keyword">local</span> red = redis.new()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置超时</span></span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to connect: &quot;</span>..err)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to connect: &quot;</span>..err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 令牌</span></span><br><span class="line"><span class="keyword">local</span> ok, err = red:auth(<span class="string">&quot;rc_redis&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to authenticate: &quot;</span>..err)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to authenticate: &quot;</span>..err)</span><br><span class="line">    red:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择redis db</span></span><br><span class="line">red:<span class="built_in">select</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取要转发的域名</span></span><br><span class="line"><span class="keyword">local</span> redis_key_domain = <span class="string">&quot;domain:&quot;</span>..ngx.var.server_name..<span class="string">&quot;:clientip:&quot;</span>..client_ip..<span class="string">&quot;:domain&quot;</span></span><br><span class="line"><span class="keyword">local</span> domain, err = red:get(redis_key_domain)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> domain <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to get &quot;</span>..redis_key_domain..<span class="string">&quot; :&quot;</span>, err)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to get &quot;</span>..redis_key_domain..<span class="string">&quot; :&quot;</span>, err)</span><br><span class="line">    red:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> domain == ngx.null <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, redis_key_domain..<span class="string">&quot; not found.&quot;</span>)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, redis_key_domain..<span class="string">&quot; not found.&quot;</span>)</span><br><span class="line">    red:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;DEBUG&quot;</span>, redis_key_domain..<span class="string">&quot; =&gt; &quot;</span>..domain)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取要转发的host</span></span><br><span class="line"><span class="keyword">local</span> redis_key_host = <span class="string">&quot;domain:&quot;</span>..ngx.var.server_name..<span class="string">&quot;:clientip:&quot;</span>..client_ip..<span class="string">&quot;:host&quot;</span></span><br><span class="line"><span class="keyword">local</span> host, err = red:get(redis_key_host)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> host <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to get &quot;</span>..redis_key_host..<span class="string">&quot; :&quot;</span>, err)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;failed to get &quot;</span>..redis_key_host..<span class="string">&quot; :&quot;</span>, err)</span><br><span class="line">    red:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> host == ngx.null <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;ERROR&quot;</span>, redis_key_host..<span class="string">&quot; not found.&quot;</span>)</span><br><span class="line">    ngx.say(<span class="string">&quot;ERROR&quot;</span>, redis_key_host..<span class="string">&quot; not found.&quot;</span>)</span><br><span class="line">    red:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">&quot;DEBUG&quot;</span>, redis_key_host..<span class="string">&quot; =&gt; &quot;</span>..host)</span><br><span class="line"></span><br><span class="line">ngx.var.target_domain = domain</span><br><span class="line">ngx.var.target_host = host</span><br><span class="line">red:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>redis connect</li>
<li>redis auth</li>
<li>redis db</li>
</ul>
<h3 id="32-redis-数据结构"><a class="markdownIt-Anchor" href="#32-redis-数据结构"></a> 3.2 Redis 数据结构</h3>
<table>
<thead>
<tr>
<th>键</th>
<th style="text-align:left">键备注</th>
<th>值</th>
<th>值备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain:&lt;request_domain&gt;:clientip:&lt;client_ip&gt;:domain</td>
<td style="text-align:left">字符串类型<br>&lt;request_domain&gt;为客户端请求的域名<br>&lt;client_ip&gt;为客户端IP<br>示例：domain:demo.com:clientip:172.17.18.237:domain</td>
<td>&lt;target_domain&gt;</td>
<td>字符串类型<br>&lt;target_domain&gt;为绑定的目标域名<br>示例：<a href="http://st2-demo.com">st2-demo.com</a></td>
</tr>
<tr>
<td>domain:&lt;request_domain&gt;:clientip:&lt;client_ip&gt;:host</td>
<td style="text-align:left">字符串类型<br>&lt;request_domain&gt;为客户端请求的域名<br>&lt;client_ip&gt;为客户端IP<br>示例：domain:demo:clientip:172.17.18.237:host</td>
<td>&lt;target_host&gt;:&lt;target_port&gt;</td>
<td>字符串类型<br>&lt;target_host&gt;为绑定的目标服务器IP<br>&lt;target_port&gt;为绑定的目标服务器端口<br>示例：172.16.0.221:80</td>
</tr>
</tbody>
</table>
<h3 id="33-禅道操作"><a class="markdownIt-Anchor" href="#33-禅道操作"></a> 3.3 禅道操作</h3>
<h4 id="331-新增代理域名"><a class="markdownIt-Anchor" href="#331-新增代理域名"></a> 3.3.1 新增代理域名</h4>
<ol>
<li>新增一份该域名的代理域名配置到对应目录
<ul>
<li>禅道生成文件到指定目录下</li>
<li>通过rsync同步改目录到OpenResty的对应目录</li>
</ul>
</li>
<li>重现加载 OpenResty Nginx模块
<ul>
<li>openresty/nginx/sbin/nginx -s reload</li>
<li>在Redis中设置一个键值，作为重新加载的标志</li>
<li>OpenResty部署服务器设置一个定时任务，检测Redis中的标志，决定是否重新加载启动Nginx</li>
</ul>
</li>
</ol>
<h4 id="332-修改用户绑定"><a class="markdownIt-Anchor" href="#332-修改用户绑定"></a> 3.3.2 修改用户绑定</h4>
<ol>
<li>按照 Redis 数据结构，修改上述2个键对应的值（新增、更新、删除）</li>
</ol>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
        <tag>OpenResty</tag>
        <tag>Nginx</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(二)-研发流水线设计</title>
    <url>/2019/09/29/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%8C)-%E7%A0%94%E5%8F%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>基于禅道设计的研发流水线，实际就是分为了两条流水线：CI和CD，CI流程就是产出最终可交付至线上的版本制品，CD流程就是将CI产出的制品最终交付至线上。在流水线执行过程中，约定了各个版本环境，如：Dev环境、IT环境、ST环境、UAT环境、PVT环境、GVT灰度验证环境、MVT量产环境等。</p>
<span id="more"></span>
<h2 id="1-流水线设计"><a class="markdownIt-Anchor" href="#1-流水线设计"></a> 1 流水线设计</h2>
<p>按照devops理念，整个开发及发布流程被设计为两条流程：持续集成和持续发布。</p>
<p>在这里持续（continuous）的概念，包含的意义是：<br>
1、流程可以反复执行；<br>
2、流程是由多个子流程组成，流程之间都是前后顺序连接，持续执行的。</p>
<p>由于我们的核心构建系统采用的是jenkins，所有流程的实现是采用的jenkins中的流水线pipeline脚本来实现的。</p>
<p>最终实现的结果就是持续交付系统主要有两条流水线：</p>
<ul>
<li>
<p>版本持续集成（CI，Continuous Integration）流水线<br>
就是对源代码进行构建，生成版本制品的过程。</p>
</li>
<li>
<p>版本持续发布（CD，Continuous Delivery）流水线<br>
就是将经过测试之后合格的版本制品发布部署到目的地的过程。</p>
</li>
</ul>
<p>我们设计的CI和CD流水线的概图如下：<br>
<img src="/2019/09/29/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%8C)-%E7%A0%94%E5%8F%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/CICD%E6%B5%81%E6%B0%B4%E7%BA%BF-new.png" alt></p>
<h2 id="2-持续集成流水线ci-continuous-integration"><a class="markdownIt-Anchor" href="#2-持续集成流水线ci-continuous-integration"></a> 2 持续集成流水线（CI, Continuous Integration）</h2>
<p>下面是一个一般的CI的流程模型：<br>
<img src="/2019/09/29/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%8C)-%E7%A0%94%E5%8F%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/CI%E6%B5%81%E6%B0%B4%E7%BA%BF-new.png" alt></p>
<h2 id="3-持续发布流水线cdcontinous-delivery"><a class="markdownIt-Anchor" href="#3-持续发布流水线cdcontinous-delivery"></a> 3 持续发布流水线（CD，Continous Delivery）</h2>
<p>下面是一个一般的CD的流程模型：<br>
<img src="/2019/09/29/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%8C)-%E7%A0%94%E5%8F%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/CD%E6%B5%81%E6%B0%B4%E7%BA%BF-new.png" alt></p>
<h2 id="4-版本和环境流程图"><a class="markdownIt-Anchor" href="#4-版本和环境流程图"></a> 4、版本和环境流程图</h2>
<p>在逻辑意义上来说，我们目前做了如下定义：</p>
<ul>
<li>环境是一个逻辑概念，在物理上的实现，它就是从物理集群内启动并运行起来的一个docker容器；</li>
<li>内网开发集群定义了系统集成测试环境（SIT，System Integration Test environment），支持的环境数量为三个：sit0、sit1、sit2。</li>
<li>内网测试集群定义了用户验收测试环境（UAT，User Acceptance Test environment），支持的环境数量为三个：uat0、uat1、uat2。</li>
<li>生产集群，不管是内网还是外网，公有云还是私有云，都定义如下三个环境：
<ul>
<li>预发布环境 pre-release</li>
<li>灰度发布环境 grey verification environment</li>
<li>正式生产环境 mass production<br>
<img src="/2019/09/29/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%8C)-%E7%A0%94%E5%8F%91%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1/%E7%89%88%E6%9C%AC%E5%8F%8A%E7%8E%AF%E5%A2%83-new.png" alt></li>
</ul>
</li>
</ul>
<h2 id="5-测试环境域名管理方案"><a class="markdownIt-Anchor" href="#5-测试环境域名管理方案"></a> 5、测试环境域名管理方案</h2>
<p>目前测试环境的访问方式主要有两种，这两种方式可以同时使用：</p>
<ul>
<li>
<p>1、不同环境不同域名方案</p>
<p>部署至不同集群环境，生成不同域名方案。</p>
<p>如：域名为&quot;<a href="http://demo.com">demo.com</a>&quot;，部署至sit0环境，则自动生成域名&quot;<a href="http://sit0-demo.com">sit0-demo.com</a>&quot;</p>
</li>
<li>
<p>2、不同环境同一域名方案</p>
<p>部署至不同集群环境，访问客户端通过**<code>域名代理</code>**访问同一域名（多环境同域名方案OpenResty方案: Nginx+lua + redis 实现根据访问者<code>IP</code>将访问请求转发到对应环境，并能对<code>IP</code>与<code>环境</code>的绑定关系进行管理，<a href="../%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%B8%89)-%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AE%BE%E8%AE%A1">方案详情参考此文</a>），访问至不同集群环境。</p>
<p>如：域名为&quot;<a href="http://demo.com">demo.com</a>&quot;，通过域名代理将访问客户端IP与目的访问集群入口域名&quot;<a href="http://sit0-demo.com">sit0-demo.com</a>&quot;绑定即可实现同一域名访问。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(五)-版本构建发布演示</title>
    <url>/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%94)-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<p>这里只是基本的版本构建和发布页面的简单展示，这里我们版本构建支持Spring cloud微服务多组件的方式，其中各个流程进度节点的状态和日志可以清晰查看。</p>
<span id="more"></span>
<h2 id="1-版本构建"><a class="markdownIt-Anchor" href="#1-版本构建"></a> 1、版本构建</h2>
<ul>
<li>一键集成、一键发布</li>
<li>不同角色负责对应流程节点的启动和确认（构建结果、开发自测、系统测试状态）</li>
<li>整个版本的进度、状态清晰明了</li>
</ul>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%94)-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E6%BC%94%E7%A4%BA/%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-new.jpg" alt></p>
<h2 id="2-版本发布"><a class="markdownIt-Anchor" href="#2-版本发布"></a> 2、版本发布</h2>
<ul>
<li>选择测试通过的版本</li>
<li>版本可以是多组件的版本，一次性部署发布</li>
<li>部署支持灰度切量部署</li>
</ul>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%94)-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E6%BC%94%E7%A4%BA/%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83-new.jpg" alt></p>
<h2 id="3-流程节点进度"><a class="markdownIt-Anchor" href="#3-流程节点进度"></a> 3、流程节点进度</h2>
<ul>
<li>支持流程节点进度查看</li>
<li>每个进度节点的状态和日志清晰查看</li>
</ul>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%94)-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E6%BC%94%E7%A4%BA/%E6%B5%81%E7%A8%8B%E8%8A%82%E7%82%B9%E8%BF%9B%E5%BA%A6-new.jpg" alt></p>
<h2 id="4-版本效能数据"><a class="markdownIt-Anchor" href="#4-版本效能数据"></a> 4、版本效能数据</h2>
<ul>
<li>每个流程节点操作者和操作时间被记录</li>
<li>每个流程消耗时间统计计算</li>
<li>整个流程效率展示在每个版本上</li>
</ul>
<p>基于此，可以统计效能指标数据</p>
<p>– 交付效率：版本构建到上线耗时</p>
<p>– 稳定性：单位时间内失败次数</p>
<p>– 吞吐量：单位时间内构建次数</p>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E4%BA%94)-%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E6%BC%94%E7%A4%BA/%E7%89%88%E6%9C%AC%E6%95%88%E8%83%BD%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1-new.jpg" alt></p>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(四)-使用流程模型</title>
    <url>/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%9B%9B)-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在基于禅道打造的持续交付系统，主要使用的流程以及各个角色在各个环节所起的作用，本文将会做一个详细的介绍说明。另外为了更好的使用，正确搭配使用禅道中的相关概念及操作，实现项目团队的项目管理和开发流程，我们把这种概念搭配和具体操作，抽象成项目管理流程模型。</p>
<span id="more"></span>
<h2 id="1-使用流程"><a class="markdownIt-Anchor" href="#1-使用流程"></a> 1、使用流程</h2>
<p>大概来说，禅道的完整使用有四个流程：<br>
1、项目创建流程（红色部分）<br>
这个流程是禅道原生的功能流程，但是optimus二次开发后做了流程定制，跟原生的使用方式有细微的差别。</p>
<p>2、迭代开发流程（蓝色部分）<br>
这个流程是原生的禅道流程，optimus只做了bug修复，没有改变现有的流程和使用方式。</p>
<p>3、版本集成流程（绿色部分）<br>
这个流程是optimus新增流程。用来支持持续交付的版本集成部分。</p>
<p>4、版本上线流程（黄色部分）<br>
这个流程是optimus新增流程。用来支持持续交付的版本发布部署和上线审批流程。</p>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%9B%9B)-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B-new.png" alt></p>
<h2 id="2-管理流程模型"><a class="markdownIt-Anchor" href="#2-管理流程模型"></a> 2、管理流程模型</h2>
<p>项目团队在使用禅道的时候，如何正确搭配使用禅道中的相关概念及操作，实现项目团队的项目管理和开发流程，我们把这种概念搭配和具体操作，抽象成项目管理流程模型，提供给业务团队理解和正确使用。</p>
<p>根据我们对业务各种项目团队管理模式和流程的初步调研，基于禅道的scrum敏捷开发模式，我们一般会有这几种团队开发协作模式：<br>
1、基本团队模式：单个产品团队 - 单个开发团队 - 单个测试团队<br>
这种模式下，一般是一个独立的产品-需求-项目-测试等是一条完整的开发流程线，跟其他项目没有关联耦合。</p>
<p>2、并行团队模式：单个产品团队 - 多个并行的开发团队 - 单个测试团队<br>
这种模式的特点：</p>
<ul>
<li>
<p>（1）开发团队有多个，开发出来的子系统或者模块是整个产品系统的组成部分，它们之间存在一定的耦合关系。</p>
</li>
<li>
<p>（2）开发团队各自的的迭代开发、发布上线等流程是一条完整的流程线，各团队流程线之间没有耦合关系。</p>
</li>
<li>
<p>（3）各开发团队由统一的项目经理进行组织协作开发，共享同一个项目开发计划，同一份需求，任务统一分配管理，测试由同一个团队负责。</p>
</li>
</ul>
<p><img src="/2019/10/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%9B%9B)-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B-new.png" alt></p>
<font color="red">
（非常重要）基本模型的一些注意事项：
<p>1、产品线下可以有多个互不相关的产品；<br>
2、一个产品，必须建立至少一个计划。计划，就是一个时间段，一般不建议超过4个周。建议每个月作为一个计划，进行逐步迭代演进。<br>
3、产品必须指定项目/迭代负责人；<br>
4、每一个需求必须关联到某一个计划上；计划跟需求是一对多的关系。<br>
5、迭代必须关联至少一个产品；<br>
6、迭代必须关联至少一个计划；建议迭代跟计划是一对一的对应关系。<br>
7、迭代可以按照计划关联需求，也可以关联某一项需求，甚至可以自建需求。<br>
8、只有项目经理可以添加迭代，并管理迭代团队，添加成员。<br>
9、不在迭代团队里的人，看不见该产品的需求，也看不见该迭代相关的任务BUG等信息，邮件抄送也不会出现在列表中。<br>
10、版本由开发主管创建并启动构建，发布由项目经理负责创建并启动部署。<br>
</p></font><p></p>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道持续交付(六)-移动端CICD</title>
    <url>/2019/11/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%85%AD)-%E7%A7%BB%E5%8A%A8%E7%AB%AFCICD/</url>
    <content><![CDATA[<p>我们其实有很多移动端的产品，所以在做完web端容器相关持续交付后，我们开始关注移动端相关的应用场景，这里我们重点切入的移动安卓打包及相关打渠道包和最终的市场投放环节，这里也和大家做个简单的分享。</p>
<p>在移动端母包构建和渠道打包上线后，给业务提效十分明显，尤其是渠道打包，基本能节省30-40%的时间，且自动化不易出错。</p>
<span id="more"></span>
<h2 id="1-移动端cicd设计"><a class="markdownIt-Anchor" href="#1-移动端cicd设计"></a> 1、移动端CICD设计</h2>
<h3 id="11-原流程调研"><a class="markdownIt-Anchor" href="#11-原流程调研"></a> 1.1、原流程调研</h3>
<p>其实持续交付的核心就是建立一个可靠的交付流水线，将软件交付整个周期进行串联起来，通过这条流水线，将交付过程标准化、自动化、可视化，同时实现关键流程和节点管控。基于此，我们分析目前移动端整体现状或者工作流程，</p>
<ul>
<li>项目管理使用禅道</li>
<li>打包工具使用Jenkins（产运、开发、测试都是在Jenkins打包 😂）</li>
<li>缺陷管理使用禅道</li>
<li>包管理暂时是Jenkins打包后通过下载手动传送，或者上传至禅道附件保存</li>
<li>渠道通过平台打包，手动下载、手动重命名、手动FTP投放、手动邮件通知等</li>
</ul>
<h3 id="12-新流程设计"><a class="markdownIt-Anchor" href="#12-新流程设计"></a> 1.2、新流程设计</h3>
<p>针对原有流程，项目/需求管理还是使用禅道原有功能，将版本母包的功能集成到禅道的版本中，同时禅道支持渠道打包和市场投放功能。</p>
<p><img src="/2019/11/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%85%AD)-%E7%A7%BB%E5%8A%A8%E7%AB%AFCICD/%E6%96%B0%E6%B5%81%E7%A8%8B-new.jpg" alt></p>
<h4 id="版本母包"><a class="markdownIt-Anchor" href="#版本母包"></a> 版本母包</h4>
<ul>
<li>版本母包管理（支持自测–&gt;系统测试–&gt;母包同步等）</li>
<li>统一母包构建入口，支持定制化打包参数设置</li>
<li>构建构成可视化</li>
</ul>
<p><img src="/2019/11/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%85%AD)-%E7%A7%BB%E5%8A%A8%E7%AB%AFCICD/%E7%89%88%E6%9C%AC%E6%9E%84%E5%BB%BA-new.jpg" alt></p>
<h4 id="渠道打包"><a class="markdownIt-Anchor" href="#渠道打包"></a> 渠道打包</h4>
<ul>
<li>批量打包管理（批量下载、自动重命名、二维码下载等）</li>
<li>渠道包自动化抽签</li>
<li>FTP自动化投放</li>
<li>渠道打包投放过程可视化</li>
</ul>
<p><img src="/2019/11/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%85%AD)-%E7%A7%BB%E5%8A%A8%E7%AB%AFCICD/%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85-new.jpg" alt></p>
<h2 id="2-多app统一页面实现定制化构建母包"><a class="markdownIt-Anchor" href="#2-多app统一页面实现定制化构建母包"></a> 2、多APP统一页面实现定制化构建母包</h2>
<h3 id="21-母包构建页面"><a class="markdownIt-Anchor" href="#21-母包构建页面"></a> 2.1、母包构建页面</h3>
<p><img src="/2019/11/26/Zentao-CICD/%E7%A6%85%E9%81%93%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98(%E5%85%AD)-%E7%A7%BB%E5%8A%A8%E7%AB%AFCICD/%E5%AE%9A%E5%88%B6%E5%8C%96%E6%89%93%E5%8C%85-new.jpg" alt></p>
<h3 id="22-定制参数设计"><a class="markdownIt-Anchor" href="#22-定制参数设计"></a> 2.2、定制参数设计</h3>
<p><strong>通过业务项目代码的仓库的gradle.properties文件添加约定注解实现</strong></p>
<ul>
<li>普通注解示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#@name:是否展示获取数据的权限弹框@show:true@enableModify:true@type:bool@description:是否展示获取数据的权限弹框</span><br><span class="line">SHOW_DATA_PERMISSION_DIALOG=false</span><br><span class="line"></span><br><span class="line">#@name:限制升级时间(天)@show:true@enableModify:true@type:int@description:限制升级的时间</span><br><span class="line">UPDATE_LIMIT_DAYS=0</span><br><span class="line"></span><br><span class="line">#@name:是否开启1*1桌面组件@show:true@enableModify:true@type:bool@description:是否开启1*1桌面小组件</span><br><span class="line">IS_USE_WIDGET_1_1=true</span><br></pre></td></tr></table></figure>
<ul>
<li>新增附件上传注解</li>
</ul>
<p><strong><code>安卓项目有附件资源依赖，附件资源以注解形式给出，通过定制参数传入</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#@name:桌面Icon压缩包@show:true@enableModify:true@type:uploadfile@fileType:zip@description:桌面Icon，必须是压缩包，目录结构符合要求，文件名为 ICON_RES.zip</span><br><span class="line">ICON_RES=</span><br><span class="line"></span><br><span class="line">#@name:启动页图片压缩包@show:true@enableModify:true@type:uploadfile@fileType:zip@description:启动页图片，必须是压缩包，目录结构符合要求，文件名为 SPLASH_RES.zip</span><br><span class="line">SPLASH_RES=</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23-构建打包jenkins-job设计"><a class="markdownIt-Anchor" href="#23-构建打包jenkins-job设计"></a> 2.3、构建打包Jenkins Job设计</h3>
<h4 id="入参说明"><a class="markdownIt-Anchor" href="#入参说明"></a> 入参说明</h4>
<ul>
<li>Jenkins主要入参</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BUILD_ID</td>
<td style="text-align:center">构建ID，构建唯一标识</td>
</tr>
<tr>
<td style="text-align:center">BUILD_PARAMS_JSON</td>
<td style="text-align:center">构建参数，json格式</td>
</tr>
<tr>
<td style="text-align:center">CALLBACK_URLS_JSON</td>
<td style="text-align:center">流水线回调url参数，json格式</td>
</tr>
<tr>
<td style="text-align:center">other params</td>
<td style="text-align:center">其他构建参数 <strong><code>【禅道无需关心】</code></strong>，<br>主要由Jenkins自己维护参数</td>
</tr>
</tbody>
</table>
<ul>
<li>通用 CALLBACK_URLS_JSON 参数示例说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 流水线Job执行结果回调</span><br><span class="line">  &quot;resultCallbackUrl&quot;: &#123;</span><br><span class="line">  	&quot;url&quot;: &quot;http://demo.2345.com&quot;,</span><br><span class="line">  	&quot;host&quot;: &quot;&quot;   // 是否绑定host返回，默认：&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BUILD_PARAMS_JSON参数说明</strong></p>
<p><strong><code>采用一个Json构建字符串，便于后期的扩展和维护</code></strong></p>
<ul>
<li>字段说明</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">commonParams</td>
<td style="text-align:center">object</td>
<td style="text-align:center">是</td>
<td style="text-align:center">构建 <strong>通用</strong> 参数Object</td>
</tr>
<tr>
<td style="text-align:center">commonParams.gitMode</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">拉取git仓库方式：branch-分支；tag-标签</td>
</tr>
<tr>
<td style="text-align:center">commonParams.gitBranchName</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">git分支名，若gitMode为tag，字段传空值：&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:center">commonParams.gitTagName</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">git标签名，若gitMode为branch，字段传空值：&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:center">commonParams.buildType</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">打包版本类型 test-内测、测试版本，release-正式版本</td>
</tr>
<tr>
<td style="text-align:center">commonParams.appName</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">应用名称，<strong>从properoties文件中解析对应选项</strong></td>
</tr>
<tr>
<td style="text-align:center">commonParams.packageName</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">应用包名，<strong>从properoties文件中解析对应选项</strong></td>
</tr>
<tr>
<td style="text-align:center">commonParams.productFlavor</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">定制的产品特性，<strong>从properoties文件中解析对应选项</strong></td>
</tr>
<tr>
<td style="text-align:center">commonParams.channel</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">渠道号,多个渠道号请用英文逗号分隔</td>
</tr>
<tr>
<td style="text-align:center">commonParams.versionName</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">外部版本号，与内部版本号对应，如：2.3.4<br>主要用于显示给用户，服务端个别接口的逻辑</td>
</tr>
<tr>
<td style="text-align:center">commonParams.versionCode</td>
<td style="text-align:center">string</td>
<td style="text-align:center">是</td>
<td style="text-align:center">内部版本号，与外部版本号对应，如：203040<br> 主要用于升级</td>
</tr>
<tr>
<td style="text-align:center">customParams</td>
<td style="text-align:center">object</td>
<td style="text-align:center">是</td>
<td style="text-align:center">构建 <strong>定制</strong> 参数Object，不存在定制参数传空object，<br> <font color="red"><strong>从properoties文件中解析生成对应的定制参数</strong></font></td>
</tr>
</tbody>
</table>
<ul>
<li>构建参数示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // ====== 构建 通用 参数说明 =====</span><br><span class="line">    &quot;commonParams&quot;: &#123;</span><br><span class="line">        &quot;gitMode&quot;: &quot;branch&quot;,  // 拉取git仓库方式：branch/tag</span><br><span class="line">        &quot;gitBranchName&quot;: &quot;branchName&quot;,  // git分支名</span><br><span class="line">        &quot;gitTagName&quot;: &quot;tagName&quot;,  //git标签名</span><br><span class="line">        &quot;buildType&quot;: &quot;test&quot;,   // 打包版本类型 test-内测、测试版本，release-正式版本</span><br><span class="line">        &quot;appName&quot;: &quot;ABC&quot;, // 应用名称</span><br><span class="line">        &quot;packageName&quot;: &quot;demo&quot;, // 应用包名</span><br><span class="line">        &quot;productFlavor&quot;: &quot;demo123&quot;, // 定制的产品特性</span><br><span class="line">        &quot;channel&quot;: &quot;UMENG_CHANNEL_VALUE&quot;, // 渠道号,多个渠道号请用英文逗号分隔</span><br><span class="line">        &quot;versionName&quot;： &quot;2.3.4.5&quot;, // 外部版本号，主要用于显示给用户，服务端个别接口的逻辑，与内部版本号对应</span><br><span class="line">        &quot;versionCode&quot;: &quot;2345&quot;, // 内部版本号，主要用于升级，与外部版本号对应</span><br><span class="line">        &quot;buildDesc&quot;: &quot;&quot;   // 构建描述</span><br><span class="line">    &#125;,</span><br><span class="line">    // ====== 构建 定制 参数说明 =====</span><br><span class="line">    &quot;customParams&quot;: &#123;</span><br><span class="line">        &quot;NEED_ENCYPT&quot;: true,  // 是否加密</span><br><span class="line">        &quot;IS_PATCH&quot;: true,   // 是否patch包</span><br><span class="line">        &quot;ICON_RES&quot;: &quot;http://download.demo.com&quot;,   // 资源附件url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>持续交付</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>Zentao</tag>
        <tag>禅道</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Pipeline语法详解</title>
    <url>/2021/05/27/Jenkins/Jenkins%20Pipeline%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>如何编写流水线文件jenkinsfile呢？其实其重点是使用<code>Pipeline语法</code>。 所以此处将重点介绍如何使用Pipeline的语法，从Pipeline插件2.5版开始，Pipeline支持两种独立的语法结构：<strong>Declarative Pipeline</strong> 和 <strong>Scripted Pipeline</strong>，两者都支持建立连续传送的Pipeline。</p>
<span id="more"></span>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h2>
<p>先说下最后的选择吧，为与BlueOcean编辑器兼容，<code>建议使用Declarative Pipeline的方式进行编写</code>,这种语法结构也会是Jenkins Pipeline未来发展的趋势。</p>
<h2 id="2-declarative-pipeline"><a class="markdownIt-Anchor" href="#2-declarative-pipeline"></a> 2 Declarative Pipeline</h2>
<p>从Pipeline2.5版本以后，Jenkins Pipeline新增了一种新的语法类型Declarative Pipeline（声明式Pipeline），它在Pipeline系统之上提供了一种更加简单和有意义的语法。</p>
<p>所有有效的Declarative Pipeline必须包含在一个pipeline块内，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123; </span><br><span class="line"><span class="comment">/* insert Declarative Pipeline here */</span> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Declarative Pipeline遵循与Groovy相同的语法规则，但有以下几点例外：</p>
<ul>
<li>
<p>Pipeline的顶层必须是块，具体来说就是：pipeline { }。</p>
</li>
<li>
<p>不用分号作为语句分隔符，每个声明必须独立一行。</p>
</li>
<li>
<p>块里只能包含Sections（章节）、Directives（指令）、 Steps（步骤）或赋值语句。</p>
</li>
<li>
<p>属性引用以无参方法的方式调用。例如，输入被视为input（）。</p>
</li>
</ul>
<h3 id="21-sections章节"><a class="markdownIt-Anchor" href="#21-sections章节"></a> 2.1 Sections（章节）</h3>
<p>Declarative Pipeline里的Sections通常包含一个或多个Directives或Steps。</p>
<h4 id="agent"><a class="markdownIt-Anchor" href="#agent"></a> agent</h4>
<p>agent指定整个Pipeline或特定stage在Jenkins环境中执行的位置。在pipeline代码块的顶层agent必须进行定义，但在stage级使用是可选的。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">见参数说明</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="参数列表"><a class="markdownIt-Anchor" href="#参数列表"></a> 参数列表</h5>
<p>为实现Pipeline可能拥有的各种用例，agent支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p>
<p><strong>any</strong></p>
<p>在任何可用的agent 上执行Pipeline或stage。例如：agent any<br>
<strong>none</strong></p>
<p>当在pipeline块的顶层使用none时，将不会为整个Pipeline运行分配全局agent ，每个stage部分将需要定义其自己的agent。</p>
<p><strong>label</strong></p>
<p>提供label标签名称，在Jenkins环境中可用的agent上执行Pipeline或stage。</p>
<p>例如：agent { label ‘my-defined-label’ }</p>
<p><strong>node</strong></p>
<p>agent { node { label ‘labelName’ } }，等同于 agent { label ‘labelName’ }，但node也允许其他选项（如customWorkspace）。</p>
<p><strong>docker</strong></p>
<p>定义此参数时，执行Pipeline或stage时会动态提供一个docker节点去运行基于Docker的Pipelines。docker还可以接受一个args参数，直接传递给docker run指令调用。</p>
<p>例如：agent { docker ‘maven:3-alpine’ }或</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        image <span class="string">&#x27;maven:3-alpine&#x27;</span></span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        args  <span class="string">&#x27;-v /tmp:/tmp&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>dockerfile</strong></p>
<p>使用从Dockerfile仓库中包含的dockerfile创建镜像文件来构建执行Pipeline或stage。为了使用此选项，Jenkinsfile必须从Multibranch Pipeline或“Pipeline from SCM&quot;中加载。</p>
<p>默认目录是在Dockerfile仓库的根目录：agent { dockerfile true }。如果Dockerfile需在另一个目录中建立，可使用dir选项：agent { dockerfile { dir ‘someSubDir’ } }。</p>
<p>还可以通过docker build …使用additionalBuildArgs选项，如agent { dockerfile { additionalBuildArgs ‘–build-arg foo=bar’ } }。</p>
<h5 id="通用选项"><a class="markdownIt-Anchor" href="#通用选项"></a> 通用选项</h5>
<p>这些是可以应用于两个或多个agent中的选项。除非明确定义，否则非必需。</p>
<p><strong>label</strong></p>
<p>string字符串。标记在哪里运行pipeline或stage</p>
<p>此选项适用于node，docker和dockerfile，并且在node中是必需的。<br>
<strong>customWorkspace</strong></p>
<p>string字符串。自定义运行的工作空间,它可以是相对路径，在这种情况下，自定义工作区将位于node节点工作空间的根目录下，也可以是绝对路径。例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    node &#123;</span><br><span class="line">        label <span class="string">&#x27;my-defined-label&#x27;</span></span><br><span class="line">        customWorkspace <span class="string">&#x27;/some/other/path&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>reuseNode</strong><br>
一个布尔值，默认为false。如果为true，则在同一工作空间中，此选项适用于docker和dockerfile，并且仅在独立stage中使用agent时才有效。</p>
<h5 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn -B clean verify&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>使用‘maven:3-alpine’的镜像创建容器，执行pipeline的所有步骤。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent none ①</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;maven:3-alpine&#x27;</span> &#125; ②</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, Maven&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Test&#x27;</span>) &#123;</span><br><span class="line">            agent &#123; docker <span class="string">&#x27;openjdk:8-jre&#x27;</span> &#125; ③</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello, JDK&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;java -version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>agent none在Pipeline顶层定义，表示将不会为整个Pipeline运行分配全局agent，每个stage需自己设置agent。</p>
<p><strong>②</strong>使用‘maven:3-alpine’的镜像创建容器，执行此阶段中的步骤。</p>
<p><strong>③</strong>使用‘openjdk:8-jre’的镜像创建容器，执行此阶段中的步骤。</p>
<h4 id="post"><a class="markdownIt-Anchor" href="#post"></a> post</h4>
<p>定义Pipeline或stage运行结束后的操作。post支持以下类型的代码块：always，changed，failure，success，unstable和aborted。这些代码块允许在Pipeline或stage运行结束时执行相关步骤，具体取决于Pipeline的运行状态。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline顶层代码块或每个stage级代码块中</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-2"><a class="markdownIt-Anchor" href="#参数列表-2"></a> 参数列表</h5>
<p><strong>always</strong></p>
<p>结束时运行，无论Pipeline运行的完成状态如何。</p>
<p><strong>changed</strong></p>
<p>只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能运行。</p>
<p><strong>failure</strong></p>
<p>只有当前Pipeline处于“失败”状态时才运行，通常用红色指示的Web UI表示。</p>
<p><strong>success</strong></p>
<p>只有当前Pipeline具有“成功”状态时才运行，通常用蓝色或绿色指示的Web UI表示。</p>
<p><strong>unstable</strong></p>
<p>只有当前Pipeline具有“不稳定”状态，一般由测试失败，代码违例等引起，才能运行。通常用黄色指示的Web UI表示。</p>
<p><strong>aborted</strong></p>
<p>只有当前Pipeline处于“中止”状态时，才会运行，通常是由于Pipeline被手动中止。通常用灰色指示的Web UI表示。</p>
<h5 id="样例-2"><a class="markdownIt-Anchor" href="#样例-2"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">&#x27;I will always say Hello again!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①post章节通常会放在pipeline末端。</p>
<p>②post代码块里包括steps章节的内容。</p>
<h4 id="stages"><a class="markdownIt-Anchor" href="#stages"></a> stages</h4>
<p>包含一个或多个stage的序列，Pipeline的大部分工作在此执行。建议stages至少包含至少一个stage指令，用于连接各个交付过程，如构建，测试和部署等。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-3"><a class="markdownIt-Anchor" href="#样例-3"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>stages章节通常跟随在agent,options等指令后面。</p>
<h4 id="steps"><a class="markdownIt-Anchor" href="#steps"></a> steps</h4>
<p>steps包含一个或多个在stage块中执行的step序列。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">是</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在每个stage代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-4"><a class="markdownIt-Anchor" href="#样例-4"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; </span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;①</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>① steps章节必须包括一个或多个step。</strong></p>
<h3 id="22-directives-指令"><a class="markdownIt-Anchor" href="#22-directives-指令"></a> 2.2 Directives （指令）</h3>
<h4 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> environment</h4>
<p>environment指令指定一系列键值对，这些键值对将被定义为所有step或stage中step的环境变量，具体取决于environment指令在Pipeline中的位置。</p>
<p>该指令支持一种特殊的方法credentials()，可通过标识符访问Jenkins环境中预定义好的Credential凭证。</p>
<p>对于“Secret Text”类型的凭据，credentials()方法需确保指定的环境变量包含Secret Text内容，对于“Standard username and password&quot;”类型的凭证，指定的环境变量需要设置为username:password。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-5"><a class="markdownIt-Anchor" href="#样例-5"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">environment</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">&#x27;clang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">&#x27;my-prefined-secret-text&#x27;</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;printenv&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>environment指令放在pipeline顶级块中，将适用pipeline所有步骤。</p>
<p><strong>②</strong>environment指令放在stage中，给定的环境变量将只适用该stage中的步骤。</p>
<p><strong>③</strong>environment块中使用credentials()方法，可以访问Jenkins环境中预定义的凭证。</p>
<h4 id="options"><a class="markdownIt-Anchor" href="#options"></a> options</h4>
<p>options指令允许在Pipeline内配置Pipeline专用选项。Pipeline本身提供了许多选项，例如buildDiscarder，它们也可以由Jenkins插件提供，例如 timestamps。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-3"><a class="markdownIt-Anchor" href="#参数列表-3"></a> 参数列表</h5>
<p><strong>buildDiscarder</strong></p>
<p>pipeline保持构建的最大个数。例如：</p>
<p>options{buildDiscarder(logRotator(numToKeepStr: ‘1’))}</p>
<p><strong>disableConcurrentBuilds</strong></p>
<p>不允许并行执行Pipeline,可用于防止同时访问共享资源等。例如：</p>
<p>options {disableConcurrentBuilds()}</p>
<p><strong>skipDefaultCheckout</strong></p>
<p>默认跳过来自源代码控制的代码。例如：</p>
<p>options {skipDefaultCheckout()}</p>
<p><strong>skipStagesAfterUnstable</strong></p>
<p>一旦构建状态进入了“Unstable”状态，就跳过此stage。例如：</p>
<p>options {skipStagesAfterUnstable()}</p>
<p><strong>timeout</strong><br>
设置Pipeline运行的超时时间。例如：</p>
<p>options {timeout(time: 1, unit: ‘HOURS’)}F</p>
<p><strong>retry</strong></p>
<p>失败后，重试整个Pipeline的次数。例如：</p>
<p>options {retry(3)}</p>
<p><strong>timestamps</strong></p>
<p>预定义由Pipeline生成的所有控制台输出时间。例如：</p>
<p>options {timestamps()}</p>
<h5 id="样例-6"><a class="markdownIt-Anchor" href="#样例-6"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123; </span><br><span class="line">        timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>) ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>设置pipeline全局的超时时间为1小时，超时后将会自动终止pipeline运行。</p>
<h4 id="parameters"><a class="markdownIt-Anchor" href="#parameters"></a> parameters</h4>
<p>parameters指令提供用户在触发Pipeline时的参数列表。这些参数值通过params对象可用于Pipeline步骤，具体用法如下</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<h5 id="参数列表-4"><a class="markdownIt-Anchor" href="#参数列表-4"></a> 参数列表</h5>
<p><strong>string</strong></p>
<p>string类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123; </span><br><span class="line">string(<span class="attr">name:</span> <span class="string">&#x27;DEPLOY_ENV&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;staging&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>booleanParam</strong></p>
<p>boolean类型的参数, 例如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">parameters &#123;</span><br><span class="line"> booleanParam(<span class="attr">name:</span> <span class="string">&#x27;DEBUG_BUILD&#x27;</span>, <span class="attr">defaultValue:</span> <span class="literal">true</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截至发稿，Jenkins社区目前已支持[booleanParam, choice, credentials, file, text, password, run, string]这几种参数类型，其他高级参数化类型也在陆续完善中。</p>
<h5 id="样例-7"><a class="markdownIt-Anchor" href="#样例-7"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="attr">name:</span> <span class="string">&#x27;PERSON&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;Mr Jenkins&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Who should I say hello to?&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Hello $&#123;params.PERSON&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggers"><a class="markdownIt-Anchor" href="#triggers"></a> triggers</h4>
<p>triggers指令定义了Pipeline自动化触发的方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成也已经存在。目前只有两个可用的触发器：cron、pollSCM和upstream。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">只能有一次，在pipeline代码块内。</td>
</tr>
</tbody>
</table>
<p><strong>cron</strong></p>
<p>接受一个cron风格的字符串来定义Pipeline触发的常规间隔，例如：</p>
<p>triggers {cron(‘H 4/* 0 0 1-5’)}</p>
<p><strong>pollSCM</strong><br>
接受一个cron风格的字符串来定义Jenkins检查SCM源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers {pollSCM(‘H 4/* 0 0 1-5’)}</p>
<p><strong>upstream</strong></p>
<p>可接受多个job名称以及一个threshold设置参数。任何一个job以符合threshold条件完成后，均可以触发Pipeline的运行。举例：{ upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p>
<h5 id="样例-8"><a class="markdownIt-Anchor" href="#样例-8"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">&#x27;H 4/* 0 0 1-5&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stage"><a class="markdownIt-Anchor" href="#stage"></a> stage</h4>
<p>stage指令包含在stages中，包含step、agent（可选）或其他特定包含于stage中的指令。实际上，Pipeline完成的所有实际工作都包含在一个或多个stage指令中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">至少一个</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">一个强制参数，一个标识stage名称的字符串。</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stages章节内。</td>
</tr>
</tbody>
</table>
<h5 id="样例-9"><a class="markdownIt-Anchor" href="#样例-9"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tools"><a class="markdownIt-Anchor" href="#tools"></a> tools</h4>
<p>通过tools可自动安装工具，并放置环境变量到PATH。如果agent none，这将被忽略。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在pipeline块内或stage指令内。</td>
</tr>
</tbody>
</table>
<p><strong>支持的Tools</strong></p>
<p>maven</p>
<p>jdk</p>
<p>gradle</p>
<h5 id="样例-10"><a class="markdownIt-Anchor" href="#样例-10"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">&#x27;apache-maven-3.0.1&#x27;</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>①</strong>调用的tool必须被预置在Jenkins中，可通过<strong>Manage Jenkins</strong>→<strong>Global Tool Configuration配置。</strong></p>
<h4 id="when"><a class="markdownIt-Anchor" href="#when"></a> when</h4>
<p>when指令允许Pipeline根据给定的条件确定是否执行该阶段。when指令必须至少包含一个条件，如果when指令包含多个条件，则只有所有子条件返回true时才会执行stage，这与子条件嵌套在allOf相同（见下面的例子）。</p>
<p>更复杂的条件结构可使用嵌套条件：not，allOf或anyOf，嵌套条件可以嵌套到任意深度。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>需要</strong></th>
<th style="text-align:left">否</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left"><strong>允许</strong></td>
<td style="text-align:left">在stage指令内。</td>
</tr>
</tbody>
</table>
<h5 id="内置条件"><a class="markdownIt-Anchor" href="#内置条件"></a> 内置条件</h5>
<p><strong>branch</strong></p>
<p>当正在构建的分支与给出的分支模式匹配时执行，例如：when { branch ‘master’ }。请注意，这仅适用于multibranch Pipeline。</p>
<p><strong>environment</strong></p>
<p>当指定的环境变量设置为指定值时执行，例如： when { environment name: ‘DEPLOY_TO’, value: ‘production’ }</p>
<p><strong>expression</strong></p>
<p>当指定的Groovy表达式求值为true时执行，例如： when { expression { return params.DEBUG_BUILD } }</p>
<p><strong>not</strong></p>
<p>当嵌套条件为false时执行。必须包含一个条件。例如：when { not { branch ‘master’ } }</p>
<p><strong>allOf</strong></p>
<p>当所有嵌套条件都为true时执行。必须至少包含一个条件。例如：when { allOf { branch ‘master’; environment name: ‘DEPLOY_TO’, value: ‘production’ } }</p>
<p><strong>anyOf</strong></p>
<p>当至少一个嵌套条件为真时执行。必须至少包含一个条件。例如：when { anyOf { branch ‘master’; branch ‘staging’ } }</p>
<h5 id="样例-11"><a class="markdownIt-Anchor" href="#样例-11"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;production&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Example Deploy&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; BRANCH_NAME ==~ <span class="regexp">/(production|staging)/</span> &#125;</span><br><span class="line">                anyOf &#123;</span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;production&#x27;</span></span><br><span class="line">                    environment <span class="attr">name:</span> <span class="string">&#x27;DEPLOY_TO&#x27;</span>, <span class="attr">value:</span> <span class="string">&#x27;staging&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Deploying&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-parallel并行"><a class="markdownIt-Anchor" href="#23-parallel并行"></a> 2.3 Parallel(并行)</h3>
<p>Declarative Pipeline的stages中可能包含多个嵌套的stage, 对相互不存在依赖的stage可以通过并行的方式执行，以提升pipeline的运行效率。</p>
<p>另外，通过在某个stage中设置“failFast true”，可实现当这个stage运行失败的时候，强迫所有parallel stages中止运行（详见下面的例子）。</p>
<h5 id="样例-12"><a class="markdownIt-Anchor" href="#样例-12"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Non-Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;This stage will be executed first.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Parallel Stage&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            failFast <span class="literal">true</span></span><br><span class="line">            parallel &#123;</span><br><span class="line">                stage(<span class="string">&#x27;Branch A&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-a&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch A&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stage(<span class="string">&#x27;Branch B&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123;</span><br><span class="line">                        label <span class="string">&quot;for-branch-b&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        echo <span class="string">&quot;On Branch B&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-steps步骤"><a class="markdownIt-Anchor" href="#24-steps步骤"></a> 2.4 Steps（步骤）</h3>
<p>Declarative Pipeline可使用Pipeline Steps手册中的所有可用步骤，以及以下仅在Declarative Pipeline中支持的步骤。</p>
<p>Pipeline Stepsreference：<a href="https://jenkins.io/doc/pipeline/steps/">https://jenkins.io/doc/pipeline/steps/</a></p>
<h4 id="script"><a class="markdownIt-Anchor" href="#script"></a> script</h4>
<p>script步骤中可以引用script Pipeline语句，并在Declarative Pipeline中执行。对于大多数用例，script在Declarative Pipeline中的步骤不是必须的，但它可以提供一个有用的加强。</p>
<h5 id="样例-13"><a class="markdownIt-Anchor" href="#样例-13"></a> 样例</h5>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Declarative Pipeline)</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">&#x27;chrome&#x27;</span>, <span class="string">&#x27;firefox&#x27;</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">&quot;Testing the $&#123;browsers[i]&#125; browser&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-scripted-pipeline"><a class="markdownIt-Anchor" href="#3-scripted-pipeline"></a> 3 Scripted Pipeline</h2>
<p>Groovy脚本不一定适合所有使用者，因此Jenkins创建了Declarative Pipeline，为编写Jenkins Pipeline提供了一种更简单、更有意义的语法。但是不可否认，由于脚本化的pipeline是基于groovy的一种DSL语言，所以与Declarative pipeline相比为Jenkins用户提供了更巨大的灵活性和可扩展性。</p>
<h3 id="31-流程控制"><a class="markdownIt-Anchor" href="#31-流程控制"></a> 3.1 流程控制</h3>
<p>Pipeline脚本同其它脚本语言一样，从上至下顺序执行，它的流程控制取决于Groovy表达式，如if/else条件语句，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (env.BRANCH_NAME == <span class="string">&#x27;master&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&#x27;I only execute on the master branch&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            echo <span class="string">&#x27;I execute elsewhere&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline脚本流程控制的另一种方式是Groovy的异常处理机制。当任何一个步骤因各种原因而出现异常时，都必须在Groovy中使用try/catch/finally语句块进行处理，举例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Jenkinsfile (Scripted Pipeline)</span></span><br><span class="line">node &#123;</span><br><span class="line">    stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sh <span class="string">&#x27;exit 1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (exc) &#123;</span><br><span class="line">            echo <span class="string">&#x27;Something failed, I should sound the klaxons!&#x27;</span></span><br><span class="line">            <span class="keyword">throw</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-steps"><a class="markdownIt-Anchor" href="#32-steps"></a> 3.2 Steps</h3>
<p>如本章开始所言，pipeline最核心和基本的部分就是“step”。从根本上来说，steps是作为Declarative pipeline和Scripted pipeline语法的最基本的语句块，来告诉jenkins应该执行什么操作。</p>
<p>Scripted pipeline不再专门将steps作为它的语法的一部分来介绍，但是在Pipeline Steps reference这篇文档中对pipeline及其插件涉及的steps做了很详细的介绍。如有需要可参考Jenkins官网对该部分的介绍。</p>
<h3 id="33-与普通groovy的区别"><a class="markdownIt-Anchor" href="#33-与普通groovy的区别"></a> 3.3 与普通Groovy的区别</h3>
<p>由于pipeline的一些个性化需求，比如在重新启动Jenkins后要求pipeline脚本仍然可以运行，那么pipeline脚本必须将相关数据做序列化，然而这一点 Groovy并不能完美的支持。</p>
<h3 id="34-declarative-pipeline和scripted-pipeline的比较"><a class="markdownIt-Anchor" href="#34-declarative-pipeline和scripted-pipeline的比较"></a> 3.4 Declarative Pipeline和Scripted Pipeline的比较</h3>
<p>共同点：</p>
<p>两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。</p>
<p>区别：</p>
<p>两者不同之处在于语法和灵活性。Declarative Pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。</p>
<h2 id="4-小结"><a class="markdownIt-Anchor" href="#4-小结"></a> 4 小结</h2>
<p>Pipeline语法是使用Jenkins Pipeline的基础，Jenkins提供了Declarative Pipeline和Scripted Pipeline两种语法结构，这两者在底层都是基于相同的Pipeline子系统，依照&quot;Pipeline as code&quot;的理念进行实现。</p>
<p>相对来说，Declarative Pipeline语法更简洁也更容易理解，而且可以与BlueOcean编辑器进行图形化操作结合，也是Jenkins社区鼓励使用的一种语法结构。</p>
<p>基于以上原因，<code>后面我们的交付流水线样例均采用 **Declarative语法** 结构进行编写。</code></p>
<h2 id="5-引用"><a class="markdownIt-Anchor" href="#5-引用"></a> 5 引用</h2>
<p><a href="https://jenkins.io/doc/book/pipeline/syntax/">Jenkins Pipeline 语法官方文档参考</a></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
</search>
